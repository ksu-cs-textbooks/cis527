<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Reverse Proxy :: CIS 527 Textbook</title><link>https://textbooks.cs.ksu.edu/cis527/5a-containers/08-reverse-proxy/index.html</link><description>Resources Slides Docker Tutorial for Beginners by TechWorld with Nana on YouTube Using Docker to Set up Nginx Reverse Proxy With Auto SSL Generation from Linux Handbook Docker Security from Docker Protect the Docker daemon socket from Docker Docker Security Cheat Sheet from OWASP Traefik Quickstart from Traefik Video Transcript As weâ€™ve seen, deploying services using Docker can make things very easy. Unfortunately, one major limitation of Docker is that the only way connect a running container to the outside world is by mapping a port on the host system to a port on the container itself. What if we want to run multiple containers that all host similar services, such as a website? Only one container can be mapped to port 80 - any other containers would either have to use a different port or be running on another host. Thankfully, one way we can get around this is by using a special piece of software known as a reverse proxy. In a nutshell, a reverse proxy will take incoming requests from the internet, analyze them to determine which container the request is directed to, and then forward that request to the correct container. It will also make sure the response from the container is directed to the correct external host. We call this a reverse proxy since it is acting as a connection into our Docker network, instead of a traditional proxy that helps containers reach the external internet.</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://textbooks.cs.ksu.edu/cis527/5a-containers/08-reverse-proxy/index.xml" rel="self" type="application/rss+xml"/></channel></rss>