




	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="CIS 527 Textbook">
    <meta name="author" content="Russell Feldhausen">
    <title>Core Networking Services :: CIS 527 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/index.html" rel="canonical" type="text/html" title="Core Networking Services :: CIS 527 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/index.xml" rel="alternate" type="application/rss+xml" title="Core Networking Services :: CIS 527 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/tele.html" rel="alternate" type="text/html" title="Core Networking Services :: CIS 527 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/embed.html" rel="alternate" type="text/html" title="Core Networking Services :: CIS 527 Textbook">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis527/css/fontawesome-all.min.css?1696352401" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis527/css/fontawesome-all.min.css?1696352401" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis527/css/nucleus.css?1696352401" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis527/css/auto-complete.css?1696352401" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis527/css/auto-complete.css?1696352401" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis527/css/perfect-scrollbar.min.css?1696352401" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis527/css/fonts.css?1696352401" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis527/css/fonts.css?1696352401" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis527/css/theme.css?1696352401" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis527/css/theme-auto.css?1696352401" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis527/css/variant.css?1696352401" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis527/css/print.css?1696352401" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cis527/css/format-print.css?1696352401" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis527/css/ie.css?1696352401" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis527/js/url.js?1696352401"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis527/js/variant.js?1696352401"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cis527/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cis527/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis527/';
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis527/css/custom.css?1696352401" rel="stylesheet">

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/index.html">
    <div id="body" class="default-animation">
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div id="top-tele-link">
            <a class="print-link" title='Teleprompter View' href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/tele.html">
              <i class="fas fa-tv fa-fw"></i>
            </a>
          </div>
          <div id="top-embed-link">
            <a class="print-link" title='Embeddable Version' href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/embed.html">
              <i class="fas fa-expand-arrows-alt fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" class="topbar-link" title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis527/index.html"><span itemprop="name">CIS 527 Textbook</span></a><meta itemprop="position" content="1"> &gt; </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Core Networking Services</span><meta itemprop="position" content="2"></li>
            </ol>
          </div>
        </div>
      </nav>
      <main id="body-inner" class="highlightable chapter narrow" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="chapter">
            <header class="headline">
            </header>


<div class="article-subheading">Chapter 3</div>
<h1 id="core-networking-services">Core Networking Services</h1>

<p>Getting your enterprise online.</p>

            <footer class="footline">

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Core Networking Services</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="introduction">Introduction</h1>


<a href="https://www.youtube.com/watch?v=1sVghyaHFMw">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><strong><a href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/01-introduction-slides/">Slides</a>
</strong></li>
</ul>
<h4 id="video-transcript">Video Transcript</h4>
<p>Welcome to Module 3! In this module, you&rsquo;ll learn all about how to link your systems up using a variety of networking tools and protocols. First, we&rsquo;ll discuss the OSI 7-Layer Networking Model and how each layer impacts your system. Then, we&rsquo;ll look at how to configure various networking options in both Windows and Linux.</p>
<p>Following that, you&rsquo;ll learn how to configure a DNS and DHCP server using Ubuntu and connect your VMs to those services to make sure they are working properly. Finally, you&rsquo;ll gain some experience working with some network troubleshooting tools, and you&rsquo;ll use those to explore a few networking protocols such as HTTP and SNMP.</p>
<p>The lab assignment will instruct you to configure remote access for the VMs you&rsquo;ve already created, as well as set up a new Linux VM to act as a DNS and DHCP server for your growing enterprise. Finally, you&rsquo;ll get some hands-on experience with the SNMP protocol and Wireshark while performing some simple network monitoring.</p>
<p>This module helps build the foundation needed for the next module, which will cover setting up centralized directory and authentication systems in both Windows and Ubuntu. A deep understanding of networking is also crucial to later modules dealing with the cloud, as the cloud itself is primarily accessed via a network connection.</p>
<p>Click the next button to continue to the next page, which introduces the OSI 7-Layer Networking Model.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="networking-overview">Networking Overview</h1>


<a href="https://www.youtube.com/watch?v=GF1rPavit4s">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><strong><a href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/02-networking-overview-slides/">Slides</a>
</strong></li>
<li><a href="http://www.tcpipguide.com/free/index.htm" target="_blank">The TCP/IP Guide</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/Packet_switching" target="_blank">Packet Switching</a>
 on Wikipedia</li>
<li><a href="https://en.wikipedia.org/wiki/Computer_network" target="_blank">Computer Network</a>
 on Wikipedia</li>
<li><a href="https://en.wikipedia.org/wiki/Spanning_Tree_Protocol" target="_blank">Spanning Tree Protocol</a>
 on Wikipedia</li>
<li><a href="https://www.geeksforgeeks.org/basics-computer-networking/" target="_blank">Basics of Computer Networking</a>
 from GeeksforGeeks</li>
</ul>
<h4 id="video-transcript">Video Transcript</h4>
<p>Before we start working with networking on our virtual machines, let&rsquo;s take a few minutes to discuss some fundamental concepts in computer networking.</p>
<p>For most people, a computer network represents a single entity connecting their personal computer to &ldquo;The Internet,&rdquo; and not much thought is given to how it works. In fact, many users believe that there is a direct line from their computer directly to the computer they are talking with. While that view isn&rsquo;t incorrect, it is definitely incomplete.</p>
<p>A computer network more closely resembles this diagram. Here we have three computers, connected by six different network devices. The devices themselves are also interconnected, giving this network a high level of redundancy. To get from Computer A to Computer B, there are several possible paths that could be taken, such as this one. If, at any time, one of those network links goes down, the network can use a different path to try and reach the desired endpoint.</p>
<p>This is all due to the fact that computer networks use a technology called &ldquo;packet switching.&rdquo; Instead of each computer talking directly with one another, as you do when you make a long-distance phone call, the messages sent between two computers can be broken into packets, and then distributed across the network. Each packet is able to make its way from the sender to the receiver, where they are reassembled into the correct message. A great analogy to this process is sending a postcard through the mail. The postal service uses the address on the postcard to get it from you to its destination, but the path taken may change each time. At each stop along the way, the post office determines what the best next step would be, hopefully getting your postcard closer to the correct destination each time. This allows your postcard to get where it needs to go, without anyone ever trying to determine the entire route beforehand.</p>
<p>When we scale this up to the size of the internet, visualized here, it is really easy to see why this is important. By using packet switching, a message can get from one end of the internet to the other without needing to take the time to figure out the entire path beforehand. It can simply move from one router to another, each time taking the most logical step toward its destination.</p>
<p>Modern computer networks use a theoretical model called the Open Systems Interconnection (or OSI) model, commonly referred to as the OSI 7-Layer model, to determine how each part of the network functions. For system administrators, this model is very helpful as it allows us to understand what different parts of the network should be doing, without worrying too much about the underlying technologies making it happen. In this module, we&rsquo;ll look at each layer of this model in detail.</p>
<p>When an application wants to communicate across a network, it generates a data packet starting at layer 7, the application layer, on the computer it is sending from. Then, the packet moves downward through the layers, with each layer adding a bit of information to the packet. Once it reaches the bottom layer, it will be transmitted to the first hop on the network, usually your home router. The router will then examine the packet to determine where it needs to go. It can do so by peeling back the layers a bit, usually to layer 3, the network layer, which contains the IP address of the destination. Then, it will send the packet on its way to the next hop. Once it is received by the destination computer, it will move the packet back up the layers, with each one peeling off its little bit of information. Finally, the packet will be received by the destination application.</p>
<p>As we discussed, each layer adds a bit of information to the packet as it moves down from the application toward the physical layer. This is called encapsulation. To help understand this, we can return to the postal service analogy from earlier. Let&rsquo;s say you&rsquo;d like to send someone a letter. You can write the letter to represent the packet of data you&rsquo;d like to send, then place it in a fancy envelope with the name of the recipient on it. Then, you&rsquo;ll place that envelope in a mailing envelope, and put the mailing address of the recipient on the outside. This is effectively encapsulating your letter, with each layer adding information about where it is destined. Then, the postal service might add a barcode to your letter, and place it in a large box with other letters headed to the same destination, further encapsulating it. Once it reaches the destination, each layer will be removed, slowly revealing the letter inside.</p>
<p>In this video, we&rsquo;ll discuss the bottom two layers of the model, the physical and data link layers. Later videos will discuss the other layers in much more detail.</p>
<p>First, the physical layer. This layer represents the individual bytes being sent across the network, one bit at a time. Typically this is handled directly in hardware, usually by your network interface card or NIC. There are many different ways this can be done, and each type of network has a different way of doing it. For this class, we won&rsquo;t be concerned with that level of detail. If you hear things such as &ldquo;100BASE-T&rdquo; or &ldquo;1000BASE-T&rdquo; or &ldquo;gigabit,&rdquo; those terms are typically referring to the physical layer.</p>
<p>The next layer up is the data link layer. At this layer, data consists of a frame, which is a standard sized chunk of data to be sent from one computer to another. A packet may fit inside of a frame, or a packet may be further divided into multiple frames, depending on the system and size of the packet. Some common technologies used at this layer are Ethernet, and the variety of 802.11 wireless protocols, among others.</p>
<p>One important concept at this layer is the media access control address, or MAC address. Each physical piece of hardware is assigned a unique, 48-bit identifier on the network. When it is written, it is usually presented as 6 pairs of 2 hexadecimal characters, separated by colons, such as the example seen here.  The MAC address is used in the data link layer to identify the many different devices on the network. For most devices, the MAC address is set by the manufacturer of the device, and is usually stored in the hardware itself. It is intended to be permanent, and globally unique in the world. However, many modern systems allow you to change, or &ldquo;spoof,&rdquo; the MAC address. This can be really useful when dealing with technologies such as virtualization. However, it also can be used maliciously. By duplicating an existing MAC address on the network, you can essentially convince the router to forward all traffic meant for that system to you, allowing you to perform man-in-the-middle attacks very easily. For most uses, however, you won&rsquo;t have to do anything to configure MAC addresses on your system, but you&rsquo;ll want to be aware of what they are and how they are used.</p>
<p>The major networking item handled by the data link layer is routing. Routing is how each node in the network determines the best path to get from one point to another on the network. It is also very important in allowing the network to have redundant connections while preventing loops across those connections. To determine how to route a packet, most networks use some variant of a spanning tree algorithm to build the network map. Let&rsquo;s see how that works.</p>
<p>To start, here is a simple network. There are 6 network segments, labeled a through f. There are also 7 network bridges connecting those segments, numbered with their ID on the network. To begin, the network bridge with the lowest ID is selected as the root bridge. Next, each bridge determines the least-cost path from itself to the root bridge. The port on that bridge in the direction of the root bridge is labelled as the root port, or RP in this diagram. Then, the shortest path from each network segment toward the root bridge is labelled as the designated port, or DP. Finally, any ports on a bridge not labelled as a root port or designated port are blocked, labelled BP on this diagram.</p>
<p>Now, to get a message from network segment f to the root bridge, it can send a message toward its designated port, on bridge 4. Then, bridge 4 will send the packet out of its root port into segment c, which will pass it along its designated port on bridge 24. The process continues until the packet reaches the root bridge. In this way, any two network segments are able to find a path to the root bridge, which will allow them to communicate.</p>
<p>If, at any time a link is broken, the spanning tree algorithm can be run again to relabel the ports. So, in this instance, segment f would now send a message toward bridge 5, since the link between segment c and bridge 24 is broken.</p>
<p>Finally, the other important concept at layer 2 is the use of virtual local area networks, or VLANs. A VLAN is simply a partition of a network at layer 2, isolating each network. In essence, what you are doing is marking certain ports of a router as part of one network or another, and telling the router to treat them as separate networks. In this way, you can simplify your network design by having systems grouped by function, and not by location.</p>
<p>Here&rsquo;s a great example. In this instance, we have a building with three floors. Traditionally, each floor would consist of its own network segment, since typically there would be one router per floor. Using VLANs, we can rearrange the network to allow all computers in the engineering department to be on the same network segment, even though they are spread across multiple floors of the building.</p>
<p>In the real world, VLANs are used extensively here at K-State. For example, all of the wireless access points are on the same VLAN, even though they are spread across campus. The same goes for any credit card terminals, since they must be protected from malicious users attempting to listen for credit card numbers on the network.</p>
<p>Most enterprise-level network routers are able to create VLANs, but many home routers do not support that feature. Since we won&rsquo;t be working with very large networks in this course, we won&rsquo;t work with VLANs directly. However, they are very important to understand, since most enterprises make use of them.</p>
<p>In the following videos, we&rsquo;ll discuss the next layers of the OSI model in more detail.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="network-layer">Network Layer</h1>


<a href="https://www.youtube.com/watch?v=Lr3wHN3IxbE">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><strong><a href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/03-network-layer-slides/">Slides</a>
</strong></li>
<li><a href="http://www.tcpipguide.com/free/index.htm" target="_blank">The TCP/IP Guide</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/Classful_network" target="_blank">Classful Networks</a>
 on Wikipedia</li>
<li><a href="https://en.wikipedia.org/wiki/Dot-decimal_notation" target="_blank">Dot-Decimal Notation</a>
 on Wikipedia</li>
<li><a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing" target="_blank">Classless Inter-Domain Routing</a>
 on Wikipedia</li>
<li><a href="http://en.wikipedia.org/wiki/Ipv6" target="_blank">IPv6</a>
 on Wikipedia</li>
<li><a href="https://en.wikipedia.org/wiki/Reserved_IP_addresses" target="_blank">Reserved IP Addresses</a>
 on Wikipedia</li>
</ul>
<h4 id="video-transcript">Video Transcript</h4>
<p>In this video, I&rsquo;ll discuss how the network layer of the 7-layer OSI model works.</p>
<p>The network layer is used to route packets from one host to another via a network. Typically, most modern networks today use the Internet Protocol or IP to perform this task, though there are other protocols available. In addition to computers, most routers also perform tasks at layer 3, since they need to be able to read and work with the address information contained in most network packets.</p>
<p>For most of the internet&rsquo;s history, the network layer used the Internet Protocol version 4, commonly known as IPv4. This slide gives the packet structure of IPv4, showing the information it adds to each packet that goes through that layer. The most important information is the source and destination IP address, giving the unique address on the network for the sender and intended recipient of this packet of information. Let&rsquo;s take a closer look at IP addresses, as they are a very important part of understanding how a computer network works.</p>
<p>For IPv4, an IP address consists of a 32-bit binary number, giving that host&rsquo;s unique identifier on the network. No two computers can share the same IP address on the same network. In most cases, the IP address is represented in Dot-Decimal notation.</p>
<p>Here&rsquo;s an example of that notation. Here, the binary number 10101100 is represented as the decimal number 172 in the first part of the IP address. Each block of 8 bits, or one byte, is represented by the corresponding decimal number, separated by a dot or period. This makes the address much easier to remember, almost like a phone number.</p>
<p>In fact, on the early days of the internet, that is exactly how it was set up. The early internet used a form of routing called &ldquo;classful networking&rdquo; to determine how IP addresses were divided. The type of network was determined by the first 4 bits of the IP address, much like an area code in modern phone numbers. There were several classes of networks, each of various sizes.</p>
<p>When an organization wanted to connect to the internet, they would register to receive a block of network addresses for their use. For a large network, such as IBM, they may receive an entire Class A network, whereas smaller organizations would receive a smaller Class B or Class C network. So, for a Class A network, the IP address would consist of the prefix 0, followed by 7 bits identifying the network. Then, the remaining 24 bits would identify the host on that network, usually assigned by the network owner. This helped standardize which parts of the IP address denoted the owner of the network, and which part denoted the unique computer on that network. For example, in this system, K-State would have the Class B network with the prefix 129.130.</p>
<p>You can even see some of this structure in this map of the IPv4 internet address space created by XKCD from several years ago. Many of the low numbered IP address blocks are assigned to a specific organization, representing the Class A networks those organizations had in the early days of the internet.</p>
<p>However, as the internet grew larger, this proved to be very inefficient. For example, many organizations did not use up all of their IP address space, leading to a large number of addresses that were unused yet unavailable for others to use. So, in the early 1990s, the internet switched to a new method of addressing, called Classless Inter-Domain Routing, or CIDR, sometimes pronounced as &ldquo;cider.&rdquo; Instead of dividing the IPv4 address space into equal sized chunks, they introduced the concept of a subnet, allowing the address space to be divided in many more flexible ways.</p>
<p>Let&rsquo;s take a look at an example. Here, we are given the IP address 192.168.2.130, with the accompanying subnet mask of 255.255.255.0. To determine which part of the IP address is the network part, simply look at the bits of the IP address that correspond to the leading 1s in the subnet mask. If you are familiar with binary operations, you are simply performing the binary <code>and</code> operation on the IP and subnet to find the network part. Similarly, for the host part, look at the part of the IP address that corresponds to the 0s in the subnet mask. This would be equivalent to performing the binary <code>and</code> operation on the IP address and the inverse of the subnet mask.</p>
<p>Here&rsquo;s yet another example. Here, you can see that the subnet mask has changed, therefore the network and host portion of the IP address is different. In this way, organizations can choose how to divide up their allocated address space to better fit their needs.</p>
<p>To help make this a bit simpler, you can use a special form of notation called CIDR Notation to describe networks. In CIDR notation, the network is denoted by its base IP address, followed by a slash and the number of 1s in the subnet mask. So, for the first example on the previous slide, the CIDR notation of that network would be 192.168.2.0/24, since the network starts at IP address 192.168.2.0 and the subnet mask of 255.255.255.0 contains 24 leading 1s. Pretty simple, right?</p>
<p>With CIDR, an IP address can be subdivided many times at different levels. For example, several years ago the website freesoft.org had this IP address. Looking at the routing structure of the internet, you would find that the first part of that IP address was assigned to MCI, a large internet service provider. They then subdivided their network among a variety of organizations, one of those being Automation Research Systems, who received a smaller block of IP addresses from MCI. They further subdivided their own addresses, and eventually one of those addresses was used by freesoft.org.</p>
<p>The groups who control the internet, the Internet Engineering Task Force (IETF) and the Internet Assigned Numbers Authority (IANA), have also marked several IP address ranges as reserved for specific uses. This slide lists some of the more important ranges. First, they have reserved three major segments for local area networks, listed at the top of this slide. Many of you are probably familiar with the third network segment, starting with 192.168, as that is typically used by home routers. If you are using the K-State wireless network, you may notice that your IP address begins with a 10, which is part of the first segment listed here. There are also three other reserved segments for various uses. We&rsquo;ll discuss a couple of them in more detail later in this module.</p>
<p>However, since many local networks may be using the same IP addresses, we must make sure that those addresses are not used on the global internet itself. To accomplish this, most home routers today perform a service called Network Address Translation, or NAT. Anytime a computer on the internal network tries to make a connection with a computer outside, the NAT router will replace the source IP address in the packet with its own IP address, while keeping track of the original internal IP address. Then, when it receives a response, it will update the incoming packet&rsquo;s destination IP address with the original internal IP of the sender. This allows multiple computers to share the same external IP address on the internet. In addition, by default NAT routers will block any incoming packets that don&rsquo;t have a corresponding outgoing request, acting as a very powerful firewall for your internal network. If you have ever hosted a server on your home network, you are probably familiar with the practice of port-forwarding on your router, which adds and entry to your router&rsquo;s NAT table telling it where to send packets it receives.</p>
<p>For many years, IPv4 worked well on the internet. However, as internet access became more common, they ran into a problem. IPv4 only specified internet addresses which were 32-bits in length. That means that there are only about 4.2 billion unique IPv4 addresses available. With a world population over 7 billion, this very quickly became a limiting factor. So, as early as the 1990s, they began work on a new version of the protocol, called IPv6. IPv6 uses 128-bit IP addresses, allowing for 340 undecillion unique addresses. According to a calculation posted online, assuming that there was a planet with 7 billion people on it for each and every star in each and every galaxy in the known universe, you could assign each of those people 10 unique IPv6 addresses and still have enough to do it again for 10,000 more universes. <a href="https://skeptics.stackexchange.com/questions/22501/are-there-enough-ipv6-addresses-for-every-atom-on-the-surface-of-the-earth" target="_blank">Source</a>
</p>
<p>IPv6 uses a very similar packet structure to IPv4, with things simplified just a bit. Also, you&rsquo;ll note here that the source and destination addresses are 4 times as large, making room for the larger address space.</p>
<p>IPv6 addresses, therefore, are quite a bit different. They are represented digitally as 128-bit binary numbers, but typically we write them as 8 groups of 4 hexadecimal digits, sometimes referred to as a &ldquo;hextet,&rdquo; separated by colons. Since IPv6 addresses are very long, we&rsquo;ve adapted a couple of ways to simplify writing them.</p>
<p>For example, consider this IPv6 address. To simplify it, first you may omit any leading zeros in a block. Then, you can combine consecutive blocks of 0 together, replacing them with a double colon. However, you may only do that step once per address, as two instances of it could make the IP address ambiguous. Finally, we can remove all spaces to get the final address, shown in the last line.</p>
<p>IPv6 addresses use a variety of different methods to denote which part of the address is the network and host part. In essence, this is somewhat similar to the old classful routing of IPv4 addresses. Each prefix on an IPv6 address indicates a different type of address, and therefore a different parsing method. This slide gives a few of the most common prefixes you might see.</p>
<p>For this course, I won&rsquo;t go too deep into IPv6 routing, as most organizations still primarily use IPv4 internally. In addition, in many cases the network hardware automatically handles converting between IPv6 and IPv4 addresses, so you&rsquo;ll spend very little time configuring IPv6 unless you are working for an ISP or very large organization.</p>
<p>In the next video, we&rsquo;ll continue this discussion on the transport layer.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="transport-layer">Transport Layer</h1>


<a href="https://www.youtube.com/watch?v=RWT4s2lzf3E">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><strong><a href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/04-transport-layer-slides/">Slides</a>
</strong></li>
<li><a href="http://www.tcpipguide.com/free/index.htm" target="_blank">The TCP/IP Guide</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank">Transmission Control Protocol</a>
 on Wikipedia</li>
<li><a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank">User Datagram Protocol</a>
 on Wikipedia</li>
<li><a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers" target="_blank">List of TCP and UDP Port Numbers</a>
 on Wikipedia</li>
</ul>
<h4 id="video-transcript">Video Transcript</h4>
<p>Now, let&rsquo;s take a look at layer 4 of the OSI model - the transport layer.</p>
<p>The transport layer is responsible for facilitating host-to-host communication between applications on two different hosts. Depending on the protocol used, it may also offer services such as reliability, flow control, sustained connections, and more. When writing a networked application, your application typically interfaces with the transport layer, creating a particular type of network socket and providing the details for creating the connection. On most computer systems today, we use either the TCP or UDP protocol at this layer, though many others exist for various uses.</p>
<p>First, let&rsquo;s look at the Transmission Control Protocol, or TCP. It was developed in the 1980s, and is really the protocol responsible for unifying the various worldwide networks into the internet we know today. TCP is a stateful protocol, meaning that it is able to maintain information about the connection between packets sent and received. It also provides many services to make it a reliable connection, from acknowledging received packets, resending missed packets, and rearranging packets received out of order, so the application gets the data in the order it was intended. Because of this, we refer to TCP as a connection-oriented protocol, since it creates a sustained connection between two applications running on two hosts on the network.</p>
<p>Here is a simplified version of the state diagram for TCP, showing the process for establishing and closing a connection. While we won&rsquo;t focus on this process in this course, you&rsquo;ll see packets for some of these states a bit later when we use Wireshark to collect network packets.</p>
<p>Since TCP is a stateful protocol, it includes several pieces of information in its packet structure. The two most notable parts are the sequence and acknowledgement fields, which allow TCP to reorganize packets into the correct order, resend missing packets, and acknowledge packets that have been successfully received. In addition, you&rsquo;ll notice that it lists a source and destination port, which we&rsquo;ll cover shortly.</p>
<p>The other most commonly used transport layer protocol is the User Datagram Protocol, or UDP. Unlike TCP, UDP is a stateless, unreliable protocol. Basically, when you send a packet using UDP, you are given no guarantees that it will arrive, or no acknowledgement when it does. In addition, each packet sent via UDP is independent, so there is no sustained connection between two hosts. While that may seem to make UDP completely useless, it actually has several unique uses. For example, the domain name system or DNS uses UDP, since each DNS lookup is essentially a single packet request and response. If a request is sent and no response is received quickly enough, it can simply resend another request, without the extra overhead of maintaining any state for the previous connection. Similarly, UDP is also helpful for streaming media. A single lost packet in a video stream is not going to cause much of an issue, and by the time it could be resent, it is already too old to be of use. So, by using UDP, the stream can have a much lower overhead, and as long as enough packets are received, the stream can be displayed.</p>
<p>Since UDP is stateless, the packet structure is also much simpler. It really just includes a source and destination port, as well as a length and checksum field to help make sure the packet itself is correct.</p>
<p>So, to quickly compare TCP and UDP, TCP is great for long, reliable connections between two hosts, whereas UDP is great for short bursts of data which could be lost in transit without affecting the application itself.</p>
<p>One great way to remember these is through the two worst jokes in the history of Computer Science.</p>
<blockquote>
<p>Want to hear a TCP joke? Well, I could tell it to you, but I&rsquo;d have to keep repeating it until I was sure you got it.</p>
</blockquote>
<blockquote>
<p>Want to hear a UDP joke? Well, I could tell it to you, but I&rsquo;d never be sure if you got it or not.</p>
</blockquote>
<p>See the difference?</p>
<p>Both TCP and UDP, as well as many other transport layer protocols, use ports to determine which packets are destined for each application. A port is simply a virtual connection point on a host, usually managed by the networking stack inside the operating system. Each port is denoted by a 16-bit number, and typically each port can only be used by one application at a time. You can think of the ports like the name on the envelope from our previous example. Since multiple people could share the same address, you have to look at the name on the envelope to determine which person should open it. Similarly, since many programs can be running on the same computer and share the same IP, you must look at the port to figure out which program should receive the packet.</p>
<p>There are several ports that are considered &ldquo;well known&rdquo; ports, meaning that they have a specific use defined. While there is no rule that says you have to adhere to these ports, and in some cases it is advantageous to ignore them, these &ldquo;well known&rdquo; ports are what allows us to communicate easily over the internet. When an application establishes an outgoing connection, it will be assigned a high-numbered &ldquo;ephemeral&rdquo; port to use as the source port, whereas the destination port is typically a &ldquo;well known&rdquo; port for the application or service it wishes to communicate with. In that way, there won&rsquo;t be any conflicts between a web browser and a web server operating on the same host. If they both tried to use port 80, it would be a problem!</p>
<p>When ports are written with IP addresses, they are typically added at the end following a colon. So, in this example, we are referencing port 1234 on the computer with IP address 192.168.0.1.</p>
<p>There are over 1000 well known ports that have common usage. Here are just a few of them, along with the associated application or protocol. We&rsquo;ll look more closely at several of these protocols later in this module.</p>
<p>So, to summarize the OSI 7-layer network model, here&rsquo;s the overall view of the postal service analogy we&rsquo;ve been using. At layers 5-7, you would write a letter to send to someone. At layer 4, the transport layer, you&rsquo;d add the name of the person you&rsquo;d like to send it to, as well as your own name. Then, at layer 3, the network layer would add the to and from mailing address. Layer 2 is the post office, which would take your envelope and add it to a box. Then, at the physical layer, a truck would transport the box containing your letter along its path. At several stops, the letter may be inspected and placed in different boxes, similar to how a router would move packets between networks. Finally, at the receiving end, each layer is peeled back, until the final letter is available to the intended recipient.</p>
<p>In networking terms, the application creates a packet at layers 5 - 7. Then, the transport layer adds the port, and the network layer adds the IP addresses to the packet. Then, the data link layer puts the packet into one or more frames, and the physical layer transmits those frames between nodes on the network. At some points, the router will look at the addresses from the third layer to help with routing the packet along its path. Finally, once it is received at the intended recipient, the layers can be removed until the packet is presented to the application.</p>
<p>I hope these videos help you better understand how the OSI 7-layer network model works. Next, we&rsquo;ll discuss how to use these concepts to connect your systems to a network, as well as how to troubleshoot things when those connections don&rsquo;t work.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="assignment">Assignment</h1>

<h3 id="lab-3---core-networking-services">Lab 3 - Core Networking Services</h3>
<!-- TODO: ISC DHCP Server is EOL - Switch to KEA -->
<h4 id="instructions">Instructions</h4>
<p>Create <strong>three</strong> virtual machines meeting the specifications given below. The best way to accomplish this is to treat this assignment like a checklist and check things off as you complete them.</p>
<p>If you have any questions about these items or are unsure what they mean, please contact the instructor. Remember that part of being a system administrator (and a software developer in general) is working within vague specifications to provide what your client is requesting, so eliciting additional information is a very necessary skill.</p>

  
  
<div class="box notices cstyle note">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
  <div class="box-content">

<p><em>To be more blunt - this specification may be purposefully designed to be vague, and it is your responsibility to ask questions about any vagaries you find. Once you begin the grading process, you cannot go back and change things, so be sure that your machines meet the expected specification regardless of what is written here. &ndash;Russ</em></p>
</div>
</div>
<p>Also, to complete many of these items, you may need to refer to additional materials and references not included in this document. System administrators must learn how to make use of available resources, so this is a good first step toward that. Of course, there&rsquo;s always <a href="http://www.google.com" target="_blank">Google</a>
!</p>
<h4 id="time-expectation">Time Expectation</h4>
<p>This lab may take anywhere from <strong>1 - 6 hours</strong> to complete, depending on your previous experience working with these tools and the speed of the hardware you are using. Installing virtual machines and operating systems is very time-consuming the first time through the process, but it will be much more familiar by the end of this course.</p>
<hr>
<h3 id="task-0-create-3-vms">Task 0: Create 3 VMs</h3>
<p>For this lab, you&rsquo;ll need to have <strong>ONE Windows 10 VM</strong>, and <strong>TWO Ubuntu 22.04 VMs</strong> available. You may reuse existing VMs from Lab 1 or Lab 2. In either case, they should have the full expected configuration applied, either manually as in Lab 1 or via the Puppet Manifest files created for Lab 2.</p>
<p>For the second Ubuntu VM, you may either quickly install and configure a new VM from scratch following the Lab 1 guide or using the Puppet Manifest from Lab 2, or you may choose to create a copy of one of your existing Ubuntu VMs. If you choose to copy one, follow these steps:</p>
<ol>
<li>Completely shut down the VM - do not suspend it.</li>
<li>Close VMware Workstation.</li>
<li>Make a copy of the entire folder containing the VM.</li>
<li>Open the new VM in VMware Workstation (look for the .VMX file in the copied folder).</li>
<li>When prompted, select &ldquo;I copied it&rdquo; to reinitialize the network interface. <strong>THIS IS IMPORTANT!</strong></li>
<li>Boot the new VM, and change the hostname to <code>cis527s-&lt;your eID&gt;</code>.
<ul>
<li><a href="https://linuxconfig.org/how-to-change-hostname-on-ubuntu-20-04-focal-fossa-linux" target="_blank">How to Change Hostname on Ubuntu 20.04</a>
 from LinuxConfig.org</li>
</ul>
</li>
</ol>

  
  
<div class="box notices cstyle warning">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div>
  <div class="box-content">

<p><em>If you do not follow these instructions carefully, the two VMs may have conflicts on the network since they&rsquo;ll have identical networking hardware and names, making this lab much more difficult or impossible to complete. <strong>You have been warned!</strong> &ndash;Russ</em></p>
</div>
</div>
<p>Clearly label your original Ubuntu VM as <strong>CLIENT</strong> and the new Ubuntu VM as <strong>SERVER</strong> in VMware Workstation so you know which is which. For this lab, we&rsquo;ll mostly be using the <strong>SERVER</strong> VM, but will use the <strong>CLIENT</strong> VM for some testing and as part of the SNMP example in Task 5.</p>

  
  
<div class="box notices cstyle note">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
  <div class="box-content">

<p><strong>VMware Fusion (Mac) Users</strong> - Before progressing any further, I recommend creating a new NAT virtual network configuration and moving all of your VMs to that network, instead of the default &ldquo;Share with my Mac&rdquo; (vmnet8) network. In this lab, you&rsquo;ll need to disable DHCP on the network you are using, which is very difficult to do on the default networks. You can find relevant instructions in <a href="https://docs.vmware.com/en/VMware-Fusion/8.0/com.vmware.fusion.using.doc/GUID-7D8E5A7D-FF0C-4975-A794-FF5A9AE83234.html" target="_blank">Add a NAT Configuration</a>
 and <a href="https://docs.vmware.com/en/VMware-Fusion/8.0/com.vmware.fusion.using.doc/GUID-84AC2D7D-4A44-4AB6-BAF8-F12C55E71A2F.html" target="_blank">Connect and Set Up the Network Adapter</a>
 in the VMware Fusion 8 Documentation.</p>
</div>
</div>
<hr>
<h3 id="task-1-remote-connections">Task 1: Remote Connections</h3>
<p><strong>PART A:</strong> On your Windows 10 VM, activate the <strong>Remote Desktop</strong> feature to allow remote access.</p>
<ul>
<li>Both the <code>cis527</code> and <code>AdminUser</code> accounts should be able to access the system remotely, as well as the default system <code>Administrator</code> account.</li>
<li>In addition, <strong>change the port</strong> used by Remote Desktop to be 34567.

  
  
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fa-fw fas fa-lightbulb"></i> Tip</div>
  <div class="box-content">

<p><em>You&rsquo;ll need to edit the registry and reboot the computer to accomplish this task. &ndash;Russ</em></p>
</div>
</div></li>
<li>You&rsquo;ll also need to make sure appropriate firewall rules are in place to accept these incoming connections, and ensure the firewall is properly enabled.</li>
<li>You can test your connection from your Linux VM using the <strong>Remmina</strong> program.</li>
</ul>
<p><strong>PART B:</strong> On your Ubuntu 22.04 VM labelled <strong>SERVER</strong>, install and activate the <strong>OpenSSH Server</strong> for remote access.</p>
<ul>
<li>Both the <code>cis527</code> and <code>AdminUser</code> accounts should be able to access the system remotely.</li>
<li>In addition, <strong>change the port</strong> used by the SSH server to 23456.</li>
<li>You&rsquo;ll also need to make sure the appropriate firewall rules are in place to accept these incoming connections, and ensure the firewall is properly enabled.</li>
<li>You can test your connection from your Windows VM using the <code>ssh</code> command in PowerShell, or from the Ubuntu 22.04 VM labelled <strong>CLIENT</strong> using the <code>ssh</code> command.

  
  
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fa-fw fas fa-lightbulb"></i> Tip</div>
  <div class="box-content">

<p><em>See the appropriate pages in the Extras module for more information about WSL and SSH. &ndash;Russ</em></p>
</div>
</div></li>
</ul>
<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://www.groovypost.com/howto/setup-use-remote-desktop-windows-10/" target="_blank">How to Set Up and Use Remote Desktop for Windows 10</a>
 from groovyPost</li>
<li><a href="https://docs.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/change-listening-port" target="_blank">How to Change the Listening Port for Remote Desktop</a>
 from Microsoft Support</li>
<li><a href="https://tweaks.com/windows/50743/change-remote-desktop-rdp-port/" target="_blank">Change Remote Desktop RDP Port</a>
 from Tweaks.com</li>
<li><a href="https://ubuntu.com/server/docs/service-openssh" target="_blank">OpenSSH Server</a>
 from the Ubuntu Server Guide</li>
<li><a href="https://help.ubuntu.com/community/SSH/OpenSSH/Configuring" target="_blank">Configuring OpenSSH</a>
 from Ubuntu Community Help Wiki</li>
<li><a href="https://linuxconfig.org/ubuntu-20-04-ssh-server" target="_blank">Ubuntu 20.04 SSH Server</a>
 from LinuxConfig.org</li>
</ul>
<hr>
<h3 id="task-2-ubuntu-static-ip-address">Task 2: Ubuntu Static IP Address</h3>
<p>On your Ubuntu 22.04 VM labelled <strong>SERVER</strong>, set up a static IP address. The host part of the IP address should end in <code>.41</code>, and the network part should remain the same as the one automatically assigned by VMware.</p>

  
  
<div class="box notices cstyle note">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
  <div class="box-content">

<p>So, if your VMware is configured to give IP addresses in the <code>192.168.138.0/24</code> network, you&rsquo;ll set the computer to use the <code>192.168.138.41</code> address.</p>
</div>
</div>
<p>You&rsquo;ll need to set the following settings correctly:</p>
<ul>
<li>IP Address</li>
<li>Subnet Mask</li>
<li>Default Gateway

  
  
<div class="box notices cstyle note">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
  <div class="box-content">

<p>VMware typically uses host <code>2</code> as its internal router to avoid conflicts with home routers, which are typically on host <code>1</code>. So, on the <code>192.168.138.0/24</code> network, the default gateway would usually be <code>192.168.138.2</code>. When in doubt, you may want to record these settings on one of your working VMs before changing them.</p>
</div>
</div></li>
<li>DNS Servers. Use one of the following options:
<ul>
<li>Your Default Gateway Address (easiest). VMware&rsquo;s internal router also acts as a DNS resolver for you, just like a home router would</li>
<li>Off Campus: <a href="https://www.opendns.com/setupguide/" target="_blank">OpenDNS</a>
 (<code>208.67.222.222</code> and <code>208.67.220.220</code>) or <a href="https://developers.google.com/speed/public-dns/" target="_blank">Google DNS</a>
 (<code>8.8.8.8</code> and <code>8.8.4.4</code>)</li>
<li>On Campus: <a href="https://www.k-state.edu/its/dns/registration.html" target="_blank">K-State&rsquo;s DNS Servers</a>
 (<code>10.130.30.52</code> and <code>10.130.30.53</code>)</li>
</ul>
</li>
</ul>

  
  
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fa-fw fas fa-lightbulb"></i> Tip</div>
  <div class="box-content">

<p><em>I personally recommend using the graphical tools in Ubuntu to configure a static IP address. There are many resources online that direct you to use netplan or edit configuration files manually, but I&rsquo;ve found that those methods aren&rsquo;t as simple and many times lead to an unusable system if done incorrectly. In any case, <strong>making a snapshot before this step</strong> is recommended, in case you have issues. &ndash;Russ</em></p>
</div>
</div>
<h4 id="resources-1">Resources</h4>
<ul>
<li><a href="https://linuxconfig.org/how-to-configure-static-ip-address-on-ubuntu-20-04-focal-fossa-desktop-server" target="_blank">How to Configure Static IP Address on Ubuntu 20.04 Focal Fossa Desktop/Server</a>
 from LinuxConfig.org</li>
<li><a href="https://linoxide.com/linux-how-to/configure-static-ip-address-ubuntu/" target="_blank">How to Configure Static IP Address on Ubuntu 18.04</a>
 from LinOxide (should work for 20.04 as well)</li>
<li><em>The Command Line Way: <a href="https://ubuntu.com/server/docs/network-configuration" target="_blank">Network Configuration</a>
 from Ubuntu Server Guide.</em></li>
</ul>
<hr>
<h3 id="task-3-dns-server">Task 3: DNS Server</h3>
<p>For this step, install the <code>bind9</code> package on the Ubuntu 22.04 VM labelled <strong>SERVER</strong>, and configure it to act as a <strong>primary master</strong> and <strong>caching nameserver</strong> for your network. You&rsquo;ll need to include the configuration for both types of uses in your config file. In addition, you&rsquo;ll need to configure both the <strong>zone file</strong> and <strong>reverse zone file</strong>, as well as <strong>forwarders</strong>.</p>

  
  
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fa-fw fas fa-lightbulb"></i> Tip</div>
  <div class="box-content">

<p><em>These instructions were built based on the <a href="https://www.digitalocean.com/community/tutorials/how-to-configure-bind-as-a-private-network-dns-server-on-ubuntu-22-04" target="_blank">How To Configure BIND as a Private Network DNS Server on Ubuntu 22.04</a>
 guide from DigitalOcean. In general, you can follow the first part of that guide to configure a Primary DNS Server, making the necessary substitutions listed below. &ndash;Russ</em></p>
</div>
</div>
<p>In your configuration, include the following items:</p>
<ul>
<li>All files:
<ul>
<li>Since you are not creating a Secondary DNS Server, you can leave out any <code>allow-transfer</code> entries from all configuration files.</li>
</ul>
</li>
<li><code>named.conf.options</code> file:
<ul>
<li>Create an ACL called <code>cis527</code> that includes your entire VM network in CIDR notation. Do not list individual IP addresses.</li>
<li>Enable recursion, and allow all computers in the <code>cis527</code> ACL to perform recursive queries.</li>
<li>Configure DNS forwarding, using one of the options given above in Task 2. I recommend using the same option as above, since you have (<em>hopefully</em>) already confirmed that it works for your situation.</li>
</ul>
</li>
<li><code>named.conf.local</code> file:
<ul>
<li>Create a zone file and reverse zone file, stored in <code>/etc/bind/zones</code>.

  
  
<div class="box notices cstyle note">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
  <div class="box-content">

<p>The DigitalOcean guide uses a <code>/16</code> subnet of <code>10.128.0.0/16</code>, and includes the <code>10.128</code> portion in the reverse zone file name and configuration. For your VM network, you are most likely using a <code>/24</code> subnet, such as <code>192.168.40.0/24</code>, so you can include the <code>192.168.40</code> portion in your zone file name and configuration. In that case, the zone name would be <code>40.168.192.in-addr.arpa</code>, and the file could be named accordingly. Similarly, in the reverse zone file itself, you would only need to include the last segment of the IP address for each PTR record, instead of the last two. Either way is correct.</p>
</div>
</div></li>
<li>List those files by path in this file in the correct zone definitions.</li>
</ul>
</li>
<li>Zone files:
<ul>
<li>Use <code>&lt;your eID&gt;.cis527.cs.ksu.edu</code> as your fully qualified domain name (FQDN) in your configuration file. (Example: <code>russfeld.cis527.cs.ksu.edu</code>)</li>
<li>Use <code>ns.&lt;your eID&gt;.cis527.cs.ksu.edu</code> as the name of your authoritative nameserver. You can use <code>admin.&lt;your eID&gt;.cis527.cs.ksu.edu</code> for the contact email address.

  
  
<div class="box notices cstyle note">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
  <div class="box-content">

<p>Since the at symbol <code>@</code> has other uses in the DNS Zone file, the email address uses a period <code>.</code> instead. So, the email address <code>admin@&lt;your eID&gt;.cis527.cs.ksu.edu</code> would be written as <code>admin.&lt;your eID&gt;.cis527.cs.ksu.edu</code>.</p>
</div>
</div></li>
<li>Don&rsquo;t forget to increment the <code>serial</code> field in the <code>SOA</code> record each time you edit the file. Otherwise your changes may not take effect.</li>
<li>Create an NS record for <code>ns.&lt;your eID&gt;.cis527.cs.ksu.edu</code>.

  
  
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fa-fw fas fa-lightbulb"></i> Tip</div>
  <div class="box-content">

<p><em>HINT: The DigitalOcean guide does not include an at symbol <code>@</code> at the beginning of that record, but I&rsquo;ve found that sometimes it is necessary to include it in order to make the <code>named-checkzone</code> command happy. See a related post on <a href="https://serverfault.com/questions/802762/reverse-dns-bind-named-checkzone-zone-ns-has-no-address-records-a-or-aaaa-err" target="_blank">ServerFault</a>
 for additional ways to solve that common error.&ndash;Russ</em></p>
</div>
</div></li>
</ul>
</li>
<li>Forward Zone File:
<ul>
<li>Create an A record for <code>ns.&lt;your eID&gt;.cis527.cs.ksu.edu</code> that points to your Ubuntu 22.04 VM labelled <strong>SERVER</strong> using the IP address in your network ending in <code>41</code> as described above.</li>
<li>Create an A record for <code>ad.&lt;your eID&gt;.cis527.cs.ksu.edu</code> that points to the IP address in your network ending in <code>42</code>. <em>(You&rsquo;ll use that IP address in the next assignment for your Windows server.)</em> This record will be for the Active Directory server in Lab 4</li>
<li>Create a CNAME record for <code>ubuntu.&lt;your eID&gt;.cis527.cs.ksu.edu</code> that redirects to <code>ns.&lt;your eID&gt;.cis527.cs.ksu.edu</code>.</li>
<li>Create a CNAME record for <code>ldap.&lt;your eID&gt;.cis527.cs.ksu.edu</code> that redirects to <code>ns.&lt;your eID&gt;.cis527.cs.ksu.edu</code>.</li>
<li>Create a CNAME record for <code>windows.&lt;your eID&gt;.cis527.cs.ksu.edu</code> that redirects to <code>ad.&lt;your eID&gt;.cis527.cs.ksu.edu</code>.</li>
</ul>
</li>
<li>Reverse Zone File:
<ul>
<li>Create a PTR record for the IP address ending in <code>41</code> that points to <code>ns.&lt;your eID&gt;.cis527.cs.ksu.edu</code>.</li>
<li>Create a PTR record for the IP address ending in <code>42</code> that points to <code>ad.&lt;your eID&gt;.cis527.cs.ksu.edu</code>.</li>
</ul>
</li>
</ul>

  
  
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fa-fw fas fa-lightbulb"></i> Tip</div>
  <div class="box-content">

<p><em>HINT: The periods, semicolons, and whitespace in the DNS configuration files are very important! Be very careful about formatting, including the trailing periods after full DNS names such as <code>ad.&lt;your eID&gt;.cis527.ksu.edu.</code>. &ndash;Russ</em></p>
</div>
</div>
<p>Once you are done, I recommend checking your configuration using the <code>named-checkconf</code> and <code>named-checkzone</code> commands. Note that the second argument to the <code>named-checkzone</code> command is the full path to your zone file, so you may need to include the file path and not just the name of the file. Example: <code>named-checkzone russfeld.cis527.cs.ksu.edu /etc/bind/zones/db.russfeld.cis527.cs.ksu.edu</code></p>
<p>Of course, you may need to update your firewall configuration to allow incoming DNS requests to this system! <strong>If your firewall is disabled and/or not configured, there will be a deduction of up to 10% of the total points on this lab</strong></p>
<p>To test your DNS server, you can set a static DNS address on either your Windows or Ubuntu VM labelled <strong>CLIENT</strong>, and use the <code>dig</code> or <code>nslookup</code> commands to verify that each DNS name and IP address is resolved properly.</p>

  
  
<div class="box notices cstyle note">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
  <div class="box-content">

<p>See the <a href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/">Bind Troubleshooting</a>
 page for some helpful screenshots of using <code>dig</code> to debug DNS server configuration.</p>
</div>
</div>

  
  
<div class="box notices cstyle warning">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div>
  <div class="box-content">

<p>As of 2023, the DNS servers on campus do not seem to support DNSSEC, which may cause issues with forwarders. If you are connected to the campus network, I recommend changing the setting in <code>named.conf.options</code> to <code>dnssec-validation no;</code> to disable DNSSEC validation - that seems to resolve the issue.</p>
</div>
</div>
<h4 id="resources-2">Resources</h4>
<ul>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-configure-bind-as-a-private-network-dns-server-on-ubuntu-22-04" target="_blank">How To Configure BIND as a Private Network DNS Server on Ubuntu 22.04</a>
 from DigitalOcean</li>
<li><a href="https://help.ubuntu.com/community/BIND9ServerHowto" target="_blank">Bind9 Server How-To</a>
 from Ubuntu Community Help Wiki</li>
<li><a href="https://ubuntu.com/server/docs/service-domain-name-service-dns" target="_blank">DNS Configuration</a>
 from Ubuntu Server Guide</li>
<li><a href="http://www.bind9.net/manuals" target="_blank">BIND Manuals</a>
 from bind9.net</li>
<li><a href="https://serverfault.com/questions/802762/reverse-dns-bind-named-checkzone-zone-ns-has-no-address-records-a-or-aaaa-err" target="_blank">Reverse DNS/bind named-checkzone &ldquo;zone NS has no address records (A or AAAA) error&rdquo;</a>
 on ServerFault (<em>common error in previous semesters</em>)</li>
</ul>
<hr>
<h3 id="task-4-dhcp-server">Task 4: DHCP Server</h3>

  
  
<div class="box notices cstyle warning">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div>
  <div class="box-content">

<p><em><strong>IMPORTANT!</strong> Make ABSOLUTELY sure that the VMware virtual network you are using is not a &ldquo;Bridged&rdquo; or &ldquo;Shared&rdquo; network before continuing. It <strong>MUST</strong> be using &ldquo;NAT&rdquo;. You can check by going to <strong>Edit &gt; Virtual Network Editor</strong> in VMware Workstation or <strong>VMware Fusion &gt; Preferences &gt; Network</strong> in VMware Fusion and looking for the settings of the network each of your VMs is configured to use. Having your network configured incorrectly while performing this step is a great way to break the network your host computer is currently connected to, and in a worst case scenario will earn you a visit from K-State&rsquo;s IT staff (and they won&rsquo;t be happy)! &ndash;Russ</em></p>
</div>
</div>
<p>Next, install the <code>isc-dhcp-server</code> package on the Ubuntu 22.04 VM labelled <strong>SERVER</strong>, and configure it to act as a DHCP server for your internal VM network.</p>
<p>In your configuration, include the following items:</p>
<ul>
<li>In general, the network settings used by this DHCP server should match those used by VMware&rsquo;s internal router.
<ul>
<li>You can also look at the network settings received by your Windows 10 VM, which at this point are from VMware&rsquo;s internal router.</li>
</ul>
</li>
<li>Use <code>&lt;your eID&gt;.cis527.cs.ksu.edu</code> as the domain name. (Example: <code>russfeld.cis527.cs.ksu.edu</code>)</li>
<li>For the dynamic IP range, use IPs ending in <code>.100</code>-<code>.250</code> in your network.</li>
<li>For DNS servers, enter the <strong>IP address</strong> of your Ubuntu 22.04 VM labelled <strong>SERVER</strong> ending in <code>.41</code>. This will direct all DHCP clients to use the DNS server configured in Task 3.
<ul>
<li>Do not use the domain name of your DNS server in your DHCP config file. While it <em>can</em> work, it depends on your DNS server being properly configured in Task 3.</li>
<li>Alternatively, for testing if your DNS server is not working properly, you can use one of the other DNS options given above in Task 2. However, you must be using the DNS server from Task 3 when graded for full credit.</li>
</ul>
</li>
</ul>

  
  
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fa-fw fas fa-lightbulb"></i> Tip</div>
  <div class="box-content">

<p><em>A working solution can be fewer than 20 lines of actual settings (not including comments) in the settings file. If you find that your configuration is becoming much longer than that, you are probably making it too difficult and complex. &ndash;Russ</em></p>
</div>
</div>
<p>Of course, you may need to update your firewall configuration to allow incoming DHCP requests to this system! <strong>If your firewall is disabled and/or not configured, there will be a deduction of up to 10% of the total points on this lab</strong></p>
<p>Once your DHCP server is installed, configured, and running properly, turn off the DHCP server in VMware. Go to <strong>Edit &gt; Virtual Network Editor</strong> in VMware Workstation or <strong>VMware Fusion &gt; Preferences &gt; Network</strong> in VMware Fusion and look for the NAT network you are using. There should be an option to disable the DHCP server for that network there.</p>
<p>Once that is complete, you can test the DHCP server using the Windows VM. To do so, restart your Windows VM so it will completely forget any current DHCP settings. When it reboots, if everything works correctly, it should get an IP address and network information from your DHCP server configured in this step. It should also be able to access the internet with those settings. An easy way to check is to run the command <code>ipconfig</code> in PowerShell and look for the DNS suffix of <code>&lt;your eID&gt;.cis527.cs.ksu.edu</code> in the output.</p>
<h4 id="resources-3">Resources</h4>
<ul>
<li><a href="https://ubuntu.com/server/docs/how-to-install-and-configure-isc-dhcp-server" target="_blank">Install and Configure ISC DHCP Server</a>
 from Ubuntu Documentation</li>
<li><a href="https://ubuntu.com/server/docs/network-dhcp" target="_blank">Dynamic Host Configuration Protocol (DHCP)</a>
 from Ubuntu Server Guide</li>
<li><a href="https://tecadmin.net/install-dhcp-server-in-ubuntu/" target="_blank">How to Install DHCP Server in Ubuntu &amp; Debian</a>
 from TecAdmin.net</li>
</ul>
<hr>
<h3 id="task-5-snmp-daemon">Task 5: SNMP Daemon</h3>
<p>Install an SNMP Daemon on the Ubuntu 22.04 VM labelled <strong>SERVER</strong>, and connect to it from your Ubuntu 22.04 VM labelled <strong>CLIENT</strong>. The DigitalOcean and Kifarunix tutorials linked below are a very good resource to follow for this part of the assignment. In that tutorial, the <strong>agent server</strong> will be your <strong>SERVER</strong> VM, and the <strong>manager server</strong> will be your <strong>CLIENT</strong> VM.</p>
<ol>
<li>In the tutorial, configure a user <code>cis527</code> using the password <code>cis527_snmp</code> for both the authentication and encryption passphrases.
<ul>
<li>This user <strong>should not</strong> be created in the <code>snmpd.conf</code> file, and any &ldquo;bootstrap&rdquo; users should be removed.</li>
</ul>
</li>
<li>The DigitalOcean tutorial includes information for modifying the configuration file to make SNMP listen on all interfaces.</li>
<li>The DigitalOcean method for creating users does not work. Use the method in the Kifarunix tutorial for configuring SNMP version 3 users.</li>
<li>The DigitalOcean tutorial includes information for downloading the MIBS and configuring a <code>~/.snmp/snmp.conf</code> file that can store your user information.</li>
</ol>
<p>Of course, you may need to update your firewall configuration to allow incoming SNMP requests to this system! <strong>If your firewall is disabled and/or not configured, there will be a deduction of up to 10% of the total points on this lab</strong></p>
<p>Then, perform the following quick activity:</p>
<ol>
<li>While logged into the <strong>CLIENT</strong> VM, use the SNMP tools to query the number of ICMP Echos (pings) that have been received by the <strong>SERVER</strong> VM. Take a <strong>screenshot</strong> with the command used and the result clearly highlighted in the terminal output.
<ul>
<li>You may use either <code>snmpget</code> and the OID number or name, or use <code>snmpwalk</code> and <code>grep</code> to find the requested information.</li>
</ul>
</li>
<li>Sent at least 10 ICMP Echos (pings) from the <strong>CLIENT</strong> VM to the <strong>SERVER</strong> VM and make sure they were properly received. Take a <strong>screenshot</strong> of the output, clearly showing how many pings were sent.
<ul>
<li>If they weren&rsquo;t received, check your firewall settings.</li>
</ul>
</li>
<li>Once again, use the SNMP tools from the <strong>CLIENT</strong> VM to query the number of ICMP Echos (pings) that have been received by the <strong>SERVER</strong> VM. It should clearly show that it has increased by the number sent during the previous command. Take a <strong>screenshot</strong> with the command used and the result clearly highlighted in the terminal output. It should match the expected output based on the previous two screenshots.</li>
</ol>

  
  
<div class="box notices cstyle note">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
  <div class="box-content">

<p><em>Be prepared to duplicate this activity during the interactive grading process! If you are unable to duplicate it, you can present the screenshots as proof that it worked before for partial credit. You may preform all three commands in a single screenshot if desired. See <a href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/05-assignment/../../images/lab3-hint.png">this example</a>
 for an idea of what the output should look like. &ndash;Russ</em></p>
</div>
</div>
<h4 id="resources-4">Resources</h4>
<ul>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-an-snmp-daemon-and-client-on-ubuntu-18-04" target="_blank">How to Install and Configure an SNMP Daemon and Client on Ubuntu 18.04</a>
 from DigitalOcean (works for 22.04 as well)</li>
<li><a href="https://kifarunix.com/install-and-configure-snmp-on-ubuntu-debian/" target="_blank">Install and Configure SNMP on Ubuntu 22.04/Debian 11</a>
 from Kifarunix (includes correct command to create user accounts)</li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-the-net-snmp-tool-suite-to-manage-and-monitor-servers" target="_blank">How to Use The Net-SNMP Tool Suite to Manage and Monitor Servers</a>
 from DigitalOcean (works for 22.04)</li>
<li><a href="https://help.ubuntu.com/community/SNMPAgent" target="_blank">SNMP Agent</a>
 from Ubuntu Community Help Wiki</li>
</ul>
<hr>
<h3 id="task-6-wireshark">Task 6: Wireshark</h3>
<p>Install Wireshark on the Ubuntu 22.04 VM labelled <strong>SERVER</strong>.</p>

  
  
<div class="box notices cstyle warning">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div>
  <div class="box-content">

<p>Firefox recently released an update the enables <a href="https://hacks.mozilla.org/2018/05/a-cartoon-intro-to-dns-over-https/" target="_blank">DNS over HTTPS</a>
 by default. So, in order to use Firefox to request DNS packets that can be captured, you&rsquo;ll need to <a href="https://support.mozilla.org/en-US/kb/firefox-dns-over-https" target="_blank">disable DNS over HTTPS</a>
 in Firefox. Alternatively, you can use <code>dig</code> to query DNS and capture the desired packets - this seems to be much easier to replicate easily.</p>
</div>
</div>
<p>Then, using Wireshark, create <strong>screenshots</strong> showing that you captured and can show the packet content of each of the following types of packets:</p>
<ol>
<li>A DNS standard query for an A record for <code>people.cs.ksu.edu</code></li>
<li>A DNS standard query response for <code>people.cs.ksu.edu</code>
<ul>
<li><em>HINT: It should respond with a CNAME record pointing to <code>invicta.cs.ksu.edu</code></em></li>
</ul>
</li>
<li>A DNS standard query response for a PTR record for <code>208.67.222.222</code> (it will look like <code>222.222.67.208.in-addr.arpa</code>)
<ul>
<li><em>HINT: It should respond with a PTR record for <code>resolver1.opendns.com</code></em></li>
</ul>
</li>
<li>An ICMP Echo (ping) request</li>
<li>An encrypted SNMP packet showing <code>cis527</code> or <code>bootstrap</code> as the username (look for the <code>msgUserName</code> field)
<ul>
<li><em>HINT: Use the commands from Task 5</em></li>
</ul>
</li>
<li>A DHCP Offer packet showing the Domain Name of <code>&lt;your ID&gt;.cis527.cs.ksu.edu</code>
<ul>
<li><em>HINT: Reboot one of your other VMs to force it to request a new IP address, or use the <code>ipconfig</code> (Windows) or <code>dhclient</code> (Ubuntu) commands to renew the IP address</em></li>
</ul>
</li>
<li>An HTTP 301: Moved Permanently or HTTP 302: Found redirect response
<ul>
<li><em>HINT: Clear the cache in your web browser, then navigate to <code>http://people.cs.ksu.edu/~sgsax</code> (without a trailing slash). It should redirect to <code>http://people.cs.ksu.edu/~sgsax/</code> (with a trailing slash).</em></li>
</ul>
</li>
<li>An HTTP Basic Authentication request, <strong>clearly showing the username and password in plaintext</strong> (expand the entries in the middle pane to find it).
<ul>
<li><em>HINT: Visit <code>http://httpbin.org/basic-auth/testuser/testpass</code> and use <code>testuser</code> | <code>testpass</code> to log in</em></li>
</ul>
</li>
</ol>

  
  
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fa-fw fas fa-lightbulb"></i> Tip</div>
  <div class="box-content">

<p><em>You&rsquo;ll present those 8 screenshots as part of the grading process for this lab, so I recommend storing them on the desktop of that VM so they are easy to find. Make sure your screenshot clearly shows the data requested. &ndash;Russ</em></p>
</div>
</div>
<h4 id="resources-5">Resources</h4>
<ul>
<li><a href="https://itsfoss.com/install-wireshark-ubuntu/" target="_blank">Install and Use Wireshark on Ubuntu Linux</a>
 from It&rsquo;s FOSS</li>
</ul>
<hr>
<h3 id="task-7-make-snapshots">Task 7: Make Snapshots</h3>
<p>In each of the virtual machines created above, create a snapshot labelled &ldquo;Lab 3 Submit&rdquo; before you submit the assignment. The grading process may require making changes to the VMs, so this gives you a restore point before grading starts.</p>
<h3 id="task-8-schedule-a-grading-time">Task 8: Schedule A Grading Time</h3>
<p>Contact the instructor and schedule a time for interactive grading. You may continue with the next module once grading has been completed.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="windows-network-configuration">Windows Network Configuration</h1>


<a href="https://www.youtube.com/watch?v=I27N8p1Ho6k">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://www.howtogeek.com/howto/19249/how-to-assign-a-static-ip-address-in-xp-vista-or-windows-7/" target="_blank">How to Assign a Static IP Address in Windows 7, 8, 10, XP, or Vista</a>
 from How-To Geek</li>
<li><a href="https://pureinfotech.com/set-static-ip-address-windows-10/" target="_blank">How to Set a Static IP Address on Windows 10</a>
 from Pureinfotech</li>
<li><a href="https://www.maketecheasier.com/common-windows-network-utilities-explained/" target="_blank">4 Common Windows Network Utilities Explained</a>
 from Make Tech Easier</li>
<li><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/tcpview" target="_blank">TCPView</a>
 from Windows Sysinternals</li>
</ul>
<h4 id="video-transcript">Video Transcript</h4>
<p>Now, let&rsquo;s look at how to manage and configure a network connection in Windows 10.</p>
<p>To begin, I&rsquo;m working in the Windows 10 VM I created for Lab 2, with the Puppet Manifest files applied.</p>
<p>First, let&rsquo;s take a quick look at how our networking is configured in VMware. This will be very important as you complete Lab 3. To view the virtual networks in VMware Workstation, click the <strong>Edit</strong> menu, then choose <strong>Virtual Network Editor</strong>. On VMware Fusion, you can find this by going to the <strong>VMware Fusion</strong> menu, selecting <strong>Preferences</strong>, then the <strong>Network</strong> option.</p>
<p>Here, we can see the virtual networks available on your system. Right now, there are two networks on my system, one &ldquo;Host-only&rdquo; network, and one &ldquo;NAT&rdquo; network. For this lab, we&rsquo;ll be working with the &ldquo;NAT&rdquo; network, so let&rsquo;s select it.</p>
<p>First, let&rsquo;s look at the network type, listed here. For this module, it is very important to confirm that the network type is set to &ldquo;NAT&rdquo; and not &ldquo;Bridged.&rdquo; If you use a &ldquo;Bridged&rdquo; network for this lab, you could easily break the network that your host computer is connected to, and in the worst case earn yourself a visit from K-State IT staff as they try to diagnose the problem. So, make sure it is set correctly here!</p>
<p>We can also see lots of information about the network&rsquo;s settings. For example, we can see the subnet IP here, and the subnet mask here. By clicking on the <strong>NAT Settings</strong> button, I can also find the gateway IP. The gateway IP is the IP of the router, which tells your system where to direct outgoing internet traffic. You&rsquo;ll want to make a note of all three of those, as we&rsquo;ll need them later to set a static IP in Windows. You can also click the <strong>DHCP Settings</strong> button to view the settings for the DHCP server, including the range of IP addresses it uses, which can also be very helpful. If you want to change any of these settings, you can click the <strong>Change Settings</strong> button at the bottom. You&rsquo;ll need Administrator privileges to make any changes.</p>
<p>Next, let&rsquo;s confirm that our VM is using that virtual network. To do so, click the <strong>VM</strong> menu, then select <strong>Settings</strong>, then choose the <strong>Network Adapter</strong>. Make sure the network connection is set to &ldquo;NAT&rdquo; here as well.</p>
<p>Ok, now let&rsquo;s look at the network configuration in Windows 10. First, you can see information about the available network adapters in the Device Manager. You can access that by right-clicking on the <strong>Start</strong> button and choosing <strong>Device Manager</strong> from the list. On that window, expand the section for <strong>Network Adapters</strong>. Here, you&rsquo;ll see that this VM has a single network adapter, as well as a couple of Bluetooth devices available.</p>
<p>Next, let&rsquo;s look at the network settings for our network adapter. You can find these by right-clicking the <strong>Start</strong> button once again, and choosing <strong>Network Connections</strong>, or by right-clicking the <strong>Network</strong> icon in the notification area and selecting <strong>Open Network &amp; Internet Settings</strong>. This will bring you to the <strong>Network Status</strong> window in the Settings app. While you can find quite a bit of information about your network settings here, I&rsquo;ve found it is much easier to click the option below for <strong>Change adapter options</strong> to get to the classic <strong>Network Connections</strong> menu on the Control Panel.</p>
<p>Here, I can see all of the available network adapters on my system, as well as a bit of information about each one. Let&rsquo;s right-click on the Ethernet0 adapter, and select <strong>Status</strong>. This window will show the current connection status, as well as some basic statistics. You can click the <strong>Details</strong> button to view even more information, such as your IP address, MAC address, and more.</p>
<p>If you&rsquo;d like to set a static IP address for this system, you&rsquo;ll need to click the <strong>Properties</strong> button at the bottom, then select the <strong>Internet Protocol Version 4 (TCP/IPv4)</strong> option, and finally <strong>Properties</strong> below that. On this window, you can set a static IP address for your system. To do so, I&rsquo;ll have to enter an IP address, subnet mask, and default gateway. For the IP address, I&rsquo;ll just make sure that it isn&rsquo;t in use on the network by picking one outside the DHCP range used by VMware. The subnet mask and default gateway should be the same as the ones you found in the VMware network settings earlier. Finally, we&rsquo;ll need to enter some DNS servers. Typically, you can just enter the same IP address as your default gateway, as most routers also can act as DNS resolvers as well. You can also use other DNS servers, such as those from OpenDNS or Google, as described in the Lab 3 assignment. Finally, I&rsquo;ll click OK to save and apply those settings. If everything is successful, I should still be able to access the internet. Let&rsquo;s open a web browser, just to be sure. For this lab assignment, you won&rsquo;t be setting a static IP on Windows 10, but you will use this process in the next module when you configure your first Windows server. The process is very similar.</p>
<p>Windows includes a number of tools to help troubleshoot and diagnose issues with your network connection. First off, the network troubleshooter available in the <strong>Network &amp; Internet Settings</strong> menu is pretty good, and can help you figure out many simple issues with your network connection.</p>
<p>Beyond that, there are a few command-line tools that you should be familiar with on Windows. So, let&rsquo;s open a PowerShell window. The first command to use is <code>ipconfig</code>. This tool has been available in Windows since the earliest versions, and it can give you quite a bit of information about your network connection. Running it without any additional options will give you your IP address, subnet mask, default gateway, and other basic information for each of your network adapters.</p>
<p>You can also run <code>ipconfig /all</code> to see all the available information about all network adapters on your system. It gives quite a bit more information, including your MAC address and DHCP lease information.</p>
<p>That command also allows you to manage your DHCP client. For example, you can use <code>ipconfig /release</code> to release all DHCP addresses, then <code>ipconfig /renew</code> to request a new DHCP address. This is very handy if you have recently reset or reconfigured your network router, as you can tell Windows to just request a new IP address without having to reboot the system.</p>
<p>It can also help manage your DNS cache. Windows maintains a cache of all DNS requests and the responses you receive, so that multiple requests for the same DNS name can be quickly resolved without needing to query again. You can use <code>ipconfig /displaydns</code> to view the cached DNS entries, and <code>ipconfig /flushdns</code> to clear the cache. This is very handy when you are trying to diagnose issues with DNS on your system. Of course, DNS caching could create a privacy concern, as the DNS cache will contain information about all websites you&rsquo;ve visited on this system. In fact, some anti-cheat programs for online video games have been found to check the Windows DNS cache, looking for entries from programs known to interfere with their games.</p>
<p>Finally, Windows includes a couple of really handy troubleshooting tools. First, you can use the <code>ping</code> command to send a simple message to any server on the internet. It uses the Internet Control Message Protocol, or ICMP, which allows it to send a simple &ldquo;echo&rdquo; request to the server. Most servers will respond to that request, allowing you to confirm that you are able to communicate with it properly across the internet. While that may seem like a very simple tool, it can actually be used in very powerful ways to diagnose a troublesome internet connection. Similarly, the <code>tracert</code> command will use a series of ICMP &ldquo;echo&rdquo; messages to trace the route across the internet from your computer to any other system. See the video on troubleshooting in this module for more information on how to troubleshoot connections using these tools.</p>
<p>The Windows Sysinternals suite of tools also includes one helpful tool, called <strong>TCPView</strong>, which allows you to view all of the active TCP connections on your system. This will show all open ports as well as any established connections. As you are working with networked programs, you can use TCPView to get a good idea of what connections are happening on your system. It can also help you diagnose some problems with programs and your firewall configuration. You can also use the <code>netstat</code> command in PowerShell to find similar information, but I prefer this graphical view.</p>
<p>That&rsquo;s all for configuring Windows networking. Stay tuned for information about configuring networking in Ubuntu!</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="ubuntu-network-configuration">Ubuntu Network Configuration</h1>


  
  
<div class="box notices cstyle note">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
  <div class="box-content">

<p><em>This video was recorded on Ubuntu 18.04, but nothing significant has changed in Ubuntu 20.04. &ndash;Russ</em></p>
</div>
</div>

<a href="https://www.youtube.com/watch?v=pI4kp3R7ZfU">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://linuxconfig.org/how-to-configure-static-ip-address-on-ubuntu-20-04-focal-fossa-desktop-server" target="_blank">How to Configure Static IP Address on Ubuntu 20.04 Focal Fossa Desktop/Server</a>
 from LinuxConfig.org</li>
<li><a href="https://ubuntu.com/server/docs/network-configuration" target="_blank">Network Configuration</a>
 from Ubuntu Server Guide</li>
<li><a href="https://www.thegeekdiary.com/ip-command-cheat-sheet-command-line-reference/" target="_blank">&lsquo;ip&rsquo; Command Cheat Sheet (Command Line Reference)</a>
 from The Geek Diary</li>
<li><a href="https://access.redhat.com/sites/default/files/attachments/rh_ip_command_cheatsheet_1214_jcs_print.pdf" target="_blank">ip Command Cheat Sheet</a>
 from Red Hat
<ul>
<li><em>Even though it is for Red Hat, most of these commands should also work in Ubuntu, and honestly, it is just a really handy cheat sheet to have!</em></li>
</ul>
</li>
<li><a href="https://www.linuxtechi.com/ip-command-examples-for-linux-users/" target="_blank">12 ip Command Examples for Linux Users</a>
 from Linuxtechi</li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-iproute2-tools-to-manage-network-configuration-on-a-linux-vps#how-to-configure-network-interfaces-and-addresses" target="_blank">How to Use IPRoute2 Tools to Manage Network Configuration on a Linux VPS</a>
 from DigitalOcean</li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-traceroute-and-mtr-to-diagnose-network-issues" target="_blank">How to Use Traceroute and MTR to Diagnose Network Issues</a>
 from DigitalOcean</li>
<li><a href="https://www.linux.com/learn/intro-to-linux/2017/7/introduction-ss-command" target="_blank">An Introduction to the ss Command</a>
 from The Linux Foundation</li>
<li><a href="https://www.binarytides.com/linux-ss-command/" target="_blank">10 Examples of Linux ss Command to Monitor Network Connections</a>
 from BinaryTides</li>
</ul>
<h4 id="video-transcript">Video Transcript</h4>
<p>Now, let&rsquo;s look at how to manage and configure a network connection in Ubuntu 18.04.</p>
<p>To begin, I&rsquo;m working in the Ubuntu VM I created for Lab 2, with the Puppet Manifest files applied.</p>
<p>First, let&rsquo;s take a quick look at how our networking is configured in VMware. This information is also covered in the video on Windows networking, but it is relevant here as well, since this will be very important as you complete Lab 3. To view the virtual networks in VMware Workstation, click the <strong>Edit</strong> menu, then choose <strong>Virtual Network Editor</strong>. On VMware Fusion, you can find this by going to the <strong>VMware Fusion</strong> menu, selecting <strong>Preferences</strong>, then the <strong>Network</strong> option.</p>
<p>Here, we can see the virtual networks available on your system. Right now, there are two networks on my system, one &ldquo;Host-only&rdquo; network, and one &ldquo;NAT&rdquo; network. For this lab, we&rsquo;ll be working with the &ldquo;NAT&rdquo; network, so let&rsquo;s select it.</p>
<p>First, let&rsquo;s look at the network type, listed here. For this module, it is very important to confirm that the network type is set to &ldquo;NAT&rdquo; and not &ldquo;Bridged.&rdquo; If you use a &ldquo;Bridged&rdquo; network for this lab, you could easily break the network that your host computer is connected to, and in the worst case earn yourself a visit from K-State IT staff as they try to diagnose the problem. So, make sure it is set correctly here!</p>
<p>We can also see lots of information about the network&rsquo;s settings. For example, we can see the subnet IP here, and the subnet mask here. By clicking on the <strong>NAT Settings</strong> button, I can also find the gateway IP. The gateway IP is the IP of the router, which tells your system where to direct outgoing internet traffic. You&rsquo;ll want to make a note of all three of those, as we&rsquo;ll need them later to set a static IP in Ubuntu. You can also click the <strong>DHCP Settings</strong> button to view the settings for the DHCP server, including the range of IP addresses it uses, which can also be very helpful. If you want to change any of these settings, you can click the <strong>Change Settings</strong> button at the bottom. You&rsquo;ll need Administrator privileges to make any changes.</p>
<p>Next, let&rsquo;s confirm that our VM is using that virtual network. To do so, click the <strong>VM</strong> menu, then select <strong>Settings</strong>, then choose the <strong>Network Adapter</strong>. Make sure the network connection is set to &ldquo;NAT&rdquo; here as well.</p>
<p>Ok, now let&rsquo;s look at the network configuration in Ubuntu. In this video, I&rsquo;ll discuss how to view and update the network settings using the GUI. There are, of course, many ways to edit configuration files on the terminal to accomplish these tasks as well. However, I&rsquo;ve found that the desktop version of Ubuntu works best if you stick with the GUI tools.</p>
<p>You can access the network settings by clicking the <strong>Activities</strong> button and searching for <strong>Settings</strong>, then selecting the <strong>Network</strong> option. As with Windows, you can right-click the networking icon in the notification area, then select the network connection you wish to change, and choosing the appropriate settings option in that menu.</p>
<p>Once in the <strong>Settings</strong> menu, click the <strong>Gear</strong> icon next to the connection you&rsquo;d like to configure. The <strong>Details</strong> tab will show you the details of the current connection, including the IP address, MAC address, default gateway, and any DNS servers. On the <strong>Identity</strong> tab, you&rsquo;ll see that you can edit the name of the connection, as well as the MAC address.</p>
<p>To change the network settings, click the <strong>IPv4</strong> tab. Here, you can choose to input a manual IP address. If I select that option, I&rsquo;ll have to enter an IP address, subnet mask, and default gateway. For the IP address, I&rsquo;ll just make sure that it isn&rsquo;t in use on the network by picking one outside the DHCP range used by VMware. The subnet mask and default gateway should be the same as the ones you found in the VMware network settings earlier. Finally, we&rsquo;ll need to enter some DNS servers. Typically, you can just enter the same IP address as your default gateway, as most routers also can act as DNS resolvers as well. You can also use other DNS servers, such as those from OpenDNS or Google, as described in the Lab 3 assignment.</p>
<p>Once you have made your changes, click the green Apply button in the upper-right corner to apply your changes. If everything is successful, I should still be able to access the internet. Let&rsquo;s open a web browser, just to be sure.</p>
<p>Ubuntu includes a number of tools to help troubleshoot and diagnose issues with your network connection. Most of these are accessed via the command line. So, let&rsquo;s open a Terminal window. First, you can view available network devices using the <code>networkctl</code> command. You can also view their status using <code>networkctl status</code>.</p>
<p>If you&rsquo;ve worked with Linux in the past, you&rsquo;re probably familiar with the <code>ifconfig</code> command. However, in recent years it has been replaced with the new <code>ip</code> command, and Ubuntu 18.04 is the first LTS version of Ubuntu that doesn&rsquo;t include <code>ifconfig</code> by default. So, we&rsquo;ll be using the newer commands in this course.</p>
<p>The first command to use is the <code>ip address show</code> command. This command will show you quite a bit of information about each network adapter on your system, including the IP address. You can also find the default gateway using <code>ip route show</code>. The new <code>ip</code> command has many powerful options that are too numerous to name here. I highly recommend reviewing some of the resources linked below the video to learn more about this powerful command.</p>
<p>In addition, Ubuntu includes a <code>ping</code> command, very similar to the one included in Windows. It uses the Internet Control Message Protocol, or ICMP, which allows it to send a simple &ldquo;echo&rdquo; request to the server. Most servers will respond to that request, allowing you to confirm that you are able to communicate with it properly across the internet. While that may seem like a very simple tool, it can actually be used in very powerful ways to diagnose a troublesome internet connection. On Ubuntu, note that by default the <code>ping</code> command will continuously send messages until you stop the command using <kbd>CTRL</kbd>+<kbd>C</kbd>. You can also specify the number of messages to send using the <code>-c &lt;number&gt;</code> option, such as <code>ping 192.168.0.1 -c 4</code> to send 4 messages to that IP address.</p>
<p>Similarly, the <code>mtr</code> command will use a series of ICMP &ldquo;echo&rdquo; messages to trace the route across the internet from your computer to any other system. This is similar to the <code>tracert</code> command on Windows, and, in fact, there is a similar <code>traceroute</code> command which can be installed on Ubuntu. However, it has been deprecated in favor of <code>mtr</code> in recent versions of Ubuntu. See the video on troubleshooting in this module for more information on how to troubleshoot connections using these tools.</p>
<p>Finally, Ubuntu also has a tool that can be used to examine TCP sockets. Previously, you would use the <code>netstat</code> command for this purpose, but it has been replaced by the new <code>ss</code> command, short for &ldquo;socket statistics.&rdquo; For example, using just the <code>ss</code> command will get a list of all sockets, much like what TCPView will show on Windows. You can find just the listening TCP sockets by using <code>ss -lt</code>. As with the other commands, there are many different uses for this command. Consult the resources linked below this video for more information on how to use it.</p>
<p>With that information in hand, you should be able to complete Task 2 of this lab assignment, which is to set a static IP address on your Ubuntu VM acting as the server. If you run into any issues, please post in the course discussion forums to get help. Good luck!</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="troubleshooting">Troubleshooting</h1>


<a href="https://www.youtube.com/watch?v=P4-axxzvVnQ">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><a href="https://www.fonerbooks.com/network.htm" target="_blank">Network Hardware Troubleshooting Flowchart</a>
 from Foner Books</li>
<li><a href="https://www.computerhope.com/issues/ch000445.htm" target="_blank">Basic Network Troubleshooting</a>
 from Computer Hope</li>
<li><a href="https://www.makeuseof.com/tag/7-simple-steps-diagnose-network-problem/" target="_blank">7 Simple Steps to Diagnose a Network Problem</a>
 from MakeUseOf</li>
<li><a href="https://www.makeuseof.com/tag/windows-network-troubleshooting-guide/" target="_blank">Windows Network Troublehshooting Guide</a>
 from MakeUseOf</li>
<li><a href="https://www.computerworld.com/article/2545775/networking/the-art-of-network-troubleshooting.html" target="_blank">The Art of Network Troubleshooting</a>
 by Greg Schaffer on Computerworld</li>
</ul>
<h4 id="video-transcript">Video Transcript</h4>
<p>When you are working with network connections, you&rsquo;ll inevitably run into issues. Understanding how to perform basic network troubleshooting is a very important skill for any system administrator to have, and it is one that you&rsquo;ll find yourself using time and time again. In this video, I&rsquo;m going to briefly review some of the steps that you can take to diagnose and fix network issues.</p>
<p>As a quick side-note, many of the resources linked below this video still refer to older Linux commands such as <code>ifconfig</code> and <code>traceroute</code> instead of their newer counterparts. So, you may have to translate the commands a bit to get them to work on newer systems, but the process and theory itself should still apply.</p>
<p>In addition, many of these troubleshooting tools can be blocked by restrictive firewall rules. So, you&rsquo;ll need to be aware of your current firewall configurations and adjust as necessary. If possible, you could disable firewalls for testing, but that also could create a security concern. So, make sure you keep in mind the fact that firewalls can also be the root cause of many of these symptoms.</p>
<p>First, when faced with any unknown network issue, the very first step is to reboot any and all devices involved if possible. This includes your computer, routers, switches, modems, and any other networking devices along the path between your system and the intended destination. While this may seem drastic, in many cases it could be a simple fault in the hardware or networking software that a quick reboot will fix, while diagnosing and fixing the error without a reboot may be nearly impossible. Of course, in an enterprise setting, you probably don&rsquo;t want to reboot your entire network infrastructure each time you have an issue, so you&rsquo;ll have to examine the tradeoffs before doing so. On a home network, however, rebooting the computer and router is a pretty negligible cost.</p>
<p>Next, I recommend determining how far across the network you can reach. In effect, this helps you pinpoint the exact root cause of the network issue, and it will tell you where to focus your efforts. This process can be performed on almost any operating system, as long as it has the <code>ping</code> command available, as well as a command to display the current IP address.</p>
<p>First, you&rsquo;ll need to determine if your computer is able to connect to itself. You can do so by using the <code>ping</code> command to send requests to the loopback interface on your system. To do so, use these two commands:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ping 127.0.0.1
</span></span><span style="display:flex;"><span>ping localhost</span></span></code></pre></div><p>The first command pings the IP address of the loopback adapter, ensuring that the networking drivers in the operating system are working properly. If that command returns an error, or is not able to connect to your system, it most likely means your networking hardware or drivers on the local system are failing and need to be fixed. The second command pings the same address, but using the commonly available DNS name <code>localhost</code>. If that command fails, but the first one succeeds, it could mean that the DNS resolver or <code>hosts</code> file on your system is corrupt. If so, that&rsquo;s where you&rsquo;ll want to focus your efforts.</p>
<p>If you are able to successfully ping yourself, the next step is to determine if you have a valid IP address. You can use either the <code>ipconfig</code> command on Windows or the <code>ip</code> commands on Linux to find your current IP address. Then, use the <code>ping</code> command to make sure you can send and receive messages via that IP address. If that step fails, you may want to release and renew your IP address if you are using DHCP, or verifying that you have the correct IP settings if you are using a static IP address. To release and renew your IP address, use the following commands on Windows:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>ipconfig /release
</span></span><span style="display:flex;"><span>ipconfig /renew</span></span></code></pre></div><p>On Linux, it is a little less straightforward, but the best way to accomplish the same task is by using these commands:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo dhclient -r
</span></span><span style="display:flex;"><span>sudo dhclient</span></span></code></pre></div><p>If you are able to get a valid IP address using these steps, you can continue on to see if you are able to access the rest of the network. If not, you may need to check your network router settings or static IP address settings to make sure they are correct.</p>
<p>Next, you&rsquo;ll want to ping the default gateway address as configured in your system. Generally, that should be the address of your router on your network. You can find that address using the <code>ipconfig</code> and <code>ip</code> commands as described above. Use the <code>ping</code> command to try and reach that address. If it works, that means you are able to successfully contact your router. If not, it could be an issue with the network cables between you and your router, or a misconfiguration of either your router or static IP address. In either case, this is sometimes the most frustrating case to deal with, as you&rsquo;ve ensured that your computer is working, but it cannot reach the core of your local network. I recommend looking at the <a href="https://www.fonerbooks.com/network.htm" target="_blank">Network Hardware Troubleshooting Flowchart</a>
 from Foner Books to try and work your way through this problem.</p>
<p>If you are able to connect with your default gateway, the next step is to see if you can reach your intended destination. If it is another computer on your network or another network, try to ping it&rsquo;s IP address. If that connection fails, most likely the problem is somewhere between your router and that computer. In that case, you&rsquo;ll want to try this troubleshooting procedure again from that computer and see if you can pinpoint the problem.</p>
<p>If you are trying to reach a website on the internet, there are a couple more steps to perform here. First, if you know the public IP address and default gateway address your internet service provider, or ISP, is providing to you, you can try to ping those addresses. If they do not work, most likely the problem is with your network modem or your local ISP. In that case, you&rsquo;ll want to get in touch with them to try and resolve the issue.</p>
<p>Next, you should try to ping a server on the internet by IP address. I usually recommend either the OpenDNS servers, which are <code>208.67.222.222</code> and <code>208.67.220.220</code>, or the Google DNS servers, which are <code>8.8.8.8</code> and <code>8.8.4.4</code>. If you can reach those servers, your connection to the internet is definitely working. If not, the issue is also most likely with your ISP, and you&rsquo;ll need to contact them to resolve the problem.</p>
<p>Finally, you should try to ping a few web addresses by the DNS names. I usually recommend using an address that is guaranteed to be available, but one that won&rsquo;t be cached on the system. I hate to say it, but using search engines other than Google, such as <a href="https://www.bing.com" target="_blank">www.bing.com</a>
 or <a href="https://www.yahoo.com" target="_blank">www.yahoo.com</a>
, are all great choices for this step. When you do so, you could receive a message that it is unable to resolve that DNS name into an IP address. If that is the case, you should check your DNS settings. If nothing else, you can always replace them with settings for OpenDNS or Google DNS and test with those addresses.</p>
<p>If you are able to resolve the IP address but are unable to reach them, then you could have a firewall issue of some kind. It is very rare that you are able to ping servers by IP address but not via the DNS names, so a firewall is the most likely culprit here.</p>
<p>Of course, if you are able to reach those sites correctly using <code>ping</code>, then the last step is to open a web browser and try to load one of those webpages. If that fails, then you&rsquo;ll need to examine either the browser software itself or the firewall. The firewall could be blocking HTTP connections, or the browser could be corrupted and need reinstalled. In either case, it is most likely a software issue at that point.</p>
<p>This is just a brief overview of some of the steps you could take to diagnose a network issue. To be honest, I could probably teach an entire course just on this one subject, since there are that many different things that could go wrong in a modern computer network. However, this should give you a set of universal tools you can use to help at least pinpoint the location of the error and narrow your search to a specific device or configuration for the source of the issue. Of course, as a last resort you can always search the internet for additional troubleshooting steps or advice, but remember that sometimes you aren&rsquo;t even able to do that when your internet isn&rsquo;t working. So, it helps to have a basic understanding of network troubleshooting and familiarity with a few quick tools to help you out.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="network-monitoring-with-wireshark">Network Monitoring with Wireshark</h1>


<a href="https://www.youtube.com/watch?v=31q_A6XuBKw">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><strong><a href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/09-network-monitoring-with-wireshark-slides/">Slides</a>
</strong></li>
<li><a href="https://www.wireshark.org/docs/" target="_blank">Wireshark Documentation</a>
</li>
<li><a href="https://www.howtogeek.com/104278/how-to-use-wireshark-to-capture-filter-and-inspect-packets/" target="_blank">How to User Wireshark to Capture, Filter, and Inspect Packets</a>
 from How-To Geek</li>
</ul>
<h4 id="video-transcript">Video Transcript</h4>
<p>Many times when you are working with networks as a system administrator, it is helpful to be able to see the actual traffic being sent across the network. Thankfully, there are many tools available to help you do just that. In this video, I&rsquo;ll introduce one of those tools, named Wireshark.</p>
<p>Wireshark originally began as Ethereal, a network monitoring program developed in 1998 by Gerald Combs. In 2006, the name was changed to Wireshark to avoid copyright issues, and has been under constant development ever since. It is completely open source under the GNU General Public License, or GPL. Wireshark can be used to capture and inspect individual packets of network traffic, and it natively understands and decodes several hundred different protocols, giving you a very handy way to inspect not only the type of traffic on your network, but the contents of those packets.</p>
<p>Before we continue, there is one important warning I must share with you. Using Wireshark on a network allows you to potentially intercept and decode any unencrypted packets on the network, regardless of whether they are sent or received by your computer. This is a violation of K-State&rsquo;s IT policies, and therefore you should never use Wireshark while directly connected to K-State&rsquo;s network. As long as you are only using Wireshark within your VM network, and you&rsquo;ve confirmed that your VM network is not set to &ldquo;bridged&rdquo; mode, you should be fine. So, make sure you are very careful when using this tool.</p>
<p>First, we&rsquo;ll need to install Wireshark. It is available for a variety of platforms. For this example, I&rsquo;ll be installing it on Ubuntu Linux. To do that, we can simply use the <code>apt</code> tool:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt update
</span></span><span style="display:flex;"><span>sudo apt install wireshark</span></span></code></pre></div><p>When you install Wireshark, you may be shown a message about installing Dumpcap in a way that allows members of the <code>wireshark</code> group to capture packets. Press <kbd>ENTER</kbd> to go to the next screen, then use the arrow keys (<kbd></kbd> and <kbd></kbd>) to select <code>&lt;Yes&gt;</code> on the menu asking if non-superusers should be able to capture packets, then press <kbd>ENTER</kbd> to confirm that option.</p>
<p>After you install Wireshark, you&rsquo;ll need to add your current user account to the <code>wireshark</code> group. If you are using the <code>cis527</code> account, you can do the following:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo usermod -a -G wireshark cis527</span></span></code></pre></div><p>Next, you&rsquo;ll need to log out and log in for the new group membership to take effect. Otherwise, you won&rsquo;t be able to directly capture packets unless you run Wireshark as <code>root</code>, which is not recommended.</p>
<p>Once you do so, you can search for &ldquo;Wireshark&rdquo; on the Activities menu to open the program. If you configured it correctly, it should show you all of your network interfaces on the first page. If you do not see them, check to make sure that your user account is properly added to the <code>wireshark</code> group and that you&rsquo;ve logged-out and logged-in again.</p>
<p>To capture packets, we must first select which interface we&rsquo;d like to listen to. Since I would like to capture packets on the actual network, I&rsquo;m doing to select <code>ens33</code> from this list. Your network interface may be named slightly differently, but it should be obvious which one is the correct one. As soon as you do so, you&rsquo;ll start seeing all of the network packets sent and received on that network interface. By default, we are not listening in &ldquo;promiscuous&rdquo; mode, which would allow us to see all the packets on the network, regardless of the sender or recipient.</p>
<p>As you can see, even if you aren&rsquo;t doing anything on the network yourself, there is always a bit of background traffic. Many of these packets are from your system and others on the network performing simple network requests from several of the background services or daemons. Most of them can be safely ignored for now, but if you are concerned about malicious network traffic on your network, any of these packets could be suspect.</p>
<p>Now, let&rsquo;s see if we can capture some interesting network traffic. First, I&rsquo;m going to open a web browser, and go to a simple web page. I&rsquo;m visiting my old personal page on the K-State CS systems, since it doesn&rsquo;t automatically redirect me to a secure connection. That way we can see the contents of the packets themselves.</p>
<p>Now that we&rsquo;ve done so, let&rsquo;s use the filtering features in Wireshark to see those packets. First, I&rsquo;m going to press the &ldquo;stop&rdquo; button at the top to stop capturing packets. Next, I&rsquo;m going to enter <code>dns</code> in the filter and press <kbd>ENTER</kbd> to only show the DNS packets in the output. There are still quite a few of them, but after scrolling through them I should see the ones I&rsquo;m looking for.</p>
<p>Here I&rsquo;ve selected the first packet I sent, which is a standard DNS query for <code>people.cs.ksu.edu</code>. Below, I can see all of the layers of the packet. The top layer shows the frame from the Physical and Data Link layers. Below that, we see the Ethernet protocol information from the Data Link layer. By expanding that, we can see the source and destination MAC addresses of the this packet. Going further, we can see the Internet Protocol Version 4 header from the Network layer, which gives the source and destination IP addresses for this packet. Note that the original destination was the default gateway, which is also the DNS server I&rsquo;ve configured this system to use.</p>
<p>We can also see that it used the User Datagram Protocol in the Transport layer. Here, we can see the source and destination ports. Notice that the source port is a very high number, meaning that it is most likely an ephemeral port on this system, whereas the destination port is 53, the &ldquo;well-known&rdquo; port for the DNS application layer protocol.</p>
<p>Finally, we can see the contents of the DNS packet itself. If we look inside, we can see the query for <code>people.cs.ksu.edu</code> inside the packet. This view helps you clearly visualize the layers of encapsulation that each packet goes through as it makes its way across the network.</p>
<p>A couple of packets later, we can see the response to the earlier query. Going back through each layer, you can see the source and destination MAC address, IP address, and port numbers are all reversed, just as you&rsquo;d expect. Finally, looking at the contents of the DNS packet, we can see the response includes an answer for the query. Here, it shows that <code>people.cs.ksu.edu</code> is a <code>CNAME</code> or &ldquo;canonical name&rdquo; record, which points to <code>invicta.cs.ksu.edu</code>, the actual server it is stored on. Thankfully, DNS will also give us the IP address of that server, which is the second record, an <code>A</code> or &ldquo;address record,&rdquo; in the response. We&rsquo;ll discuss these DNS record types in a later video.</p>
<p>Depending on your browser&rsquo;s configuration, you may also see additional DNS queries for the each URL included on the page that was loaded. For example, here I see queries for <code>projecteuler.net</code>, <code>russfeld.me</code>, and <code>beattieunioncemetery.org</code>, which are all linked at the bottom of my page. Most browsers do this as a way to speed up subsequent requests, as they assume you are likely to click on at least one of those links while visiting that page. Since it has already done the DNS query, it is one step closer to loading that page for you. In fact, many browsers may already send requests to that server in the background and have the page cached and ready to go before you click the link.</p>
<p>This is a very brief introduction to the power of Wireshark and how to use it to capture packets. Over the next few videos, we&rsquo;ll explore some Application layer protocols and use Wireshark to help us explore the packets for each one. In the meantime, I encourage you to play around a bit with Wireshark and see what sorts of packets you can see on your own.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="dhcp">DHCP</h1>


<a href="https://www.youtube.com/watch?v=BytkMTK84jM">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><strong><a href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/10-dhcp-slides/">Slides</a>
</strong></li>
<li><a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" target="_blank">Dynamic Host Configuration Protocol (DHCP)</a>
 on Wikipedia</li>
<li><a href="https://en.wikipedia.org/wiki/Bootstrap_Protocol" target="_blank">Bootstrap Protocol (BOOTP)</a>
 on Wikipedia</li>
<li><a href="https://www.lifewire.com/what-is-dhcp-2625848" target="_blank">What is DHCP? (Dynamic Host Configuration Protocol)</a>
 from Lifewire</li>
<li><a href="https://www.isc.org/downloads/dhcp/" target="_blank">ISC DHCP</a>
 Open Source Software for DHCP Servers</li>
<li><a href="https://tools.ietf.org/html/rfc2131" target="_blank">Dynamic Host Configuration Protocol</a>
 (RFC 2131) Standard from IETF</li>
<li><a href="https://en.wikipedia.org/wiki/Link-local_address" target="_blank">Link-Local Address</a>
 on Wikipedia</li>
</ul>
<h4 id="video-transcript">Video Transcript</h4>
<p>The Dynamic Host Configuration Protocol, or DHCP, is a core part of operating any network today. This video will introduce DHCP and demonstrate how it works. In your lab assignment, you&rsquo;ll be setting up and configuring your own DHCP server, so this information will be very helpful in completing that task.</p>
<p>As a quick note, much of the information in this lecture is adapted from information provided by Seth Galitzer, our system administrator here in K-State CS. He created the original slides as part of a guest lecture in this course when it was offered on campus, and was gracious enough to share this information for future versions of the course.</p>
<p>First, let&rsquo;s review a bit of internet history. Prior to the 1980s, there were many networks that existed across the world, but they were not interconnected. In 1982, the TCP and IP protocols were developed, with the aim of unifying all of those networks into a grand interconnected network, or &ldquo;internet.&rdquo; At the time, there were only a few hundred computers worldwide which would be part of this network, so manual configuration wasn&rsquo;t too bad. As there were more and more computers on the internet, they realized that it would be helpful to have a way to automatically configure new systems. So, in 1985, the Bootstrap Protocol, or BOOTP, was developed in order to provide some automation. However, BOOTP was very limited, and only could perform some functions. As the internet was growing by leaps and bounds at this point, they decided a new solution was needed. So, in 1989, they formed the DHC working group to build a better way. In 1993, their initial specification for DHCP was released, and in 1996 the first working server was available. A year later, in 1997, they finalized the protocol into the standard it is today.</p>
<p>There were some major reasons why DHCP was needed. As discussed, the internet, as well as many corporate networks, were getting larger and larger, and manual configuration of those networks was simply too difficult to manage. In addition, with the introduction of laptops and mobile devices, computers needed to be able to seamlessly move from network to network without needing additional configuration. So, they really needed a method to automatically configure network settings on a computer when it initially connected to a network. Hence, the creation of DHCP.</p>
<p>Beyond that, there are many features built in to DHCP to make it a very powerful system. First, it includes the concept of &ldquo;leasing&rdquo; an IP address. When a system first connects to the network, it is given an IP address and a length of time it may keep that IP address. Once that time is up, it must renew its lease on that IP, or the system may assign that IP to a new system. In this way, as systems come and go, the DHCP server can reuse IP addresses once the leases have expired. In addition to IP addresses, modern DHCP servers can also send additional information about the network, such as DNS servers, SMTP servers, and more. Using DHCP, modern computers can be much more portable, allowing them to seamlessly connect to any network providing a DHCP server. Finally, even though DHCP is very powerful, there are many instances where a static IP address is preferred, such as for servers and printers. Thankfully, DHCP is fully compatible with static IP addresses on the same network. All that is required is a bit of configuration to mark which sections of the network should be automatically configured and which shouldn&rsquo;t. In addition, many DHCP servers can be configured to always give the same IP address to a particular host, providing even more flexibility.</p>
<p>Let&rsquo;s dig a bit deeper in to the DHCP protocol itself to see how it works. In essence, DHCP is a 4-step handshake that happens when any new computer connects to a network. In the first step, the computer sends out a special &ldquo;discover&rdquo; message to every system on the network, asking for help to connect. That message is sent to the destination IP address 255.255.255.255, which is a special broadcast address telling the network to send that packet to every computer on the network. This allows the computer to communicate, even if it doesn&rsquo;t have the proper network settings yet. In the second step, a DHCP server will receive that &ldquo;discover&rdquo; message, and send back an &ldquo;offer&rdquo; message containing an IP address and additional settings the computer could use. Once the computer receives that message, it will then broadcast a &ldquo;request&rdquo; message, which requests a specific IP address. It could be one it was using previously if it is renewing a lease, otherwise it will be one from the &ldquo;offer&rdquo; message it received. When the DHCP server receives that &ldquo;request&rdquo; message, if that IP address is still available, it will respond with an &ldquo;acknowledge&rdquo; message confirming the address, or it will respond with an error to the computer, which starts the process over again. Once the computer receives an &ldquo;acknowledge&rdquo; message, it can then configure its network settings using the information it has received, and it is good to go.</p>
<p>So, in short, it goes something like this:</p>
<ol>
<li>Client: &ldquo;Hi, I&rsquo;m new!&rdquo;</li>
<li>Server: &ldquo;Welcome! Here&rsquo;s some settings you could use.&rdquo;</li>
<li>Client: &ldquo;Cool! Can I use these settings?&rdquo;</li>
<li>Server&quot; &ldquo;Sure can! You are all set.&rdquo;</li>
</ol>
<p>DHCP also works with multiple servers. Since each server will receive the &ldquo;discover&rdquo; message, it will respond with its own &ldquo;offer&rdquo; message. The computer can then choose which &ldquo;offer&rdquo; to respond to, and the servers will only respond with an &ldquo;acknowledge&rdquo; message if it was the original sender of the offer. In that way, you can have multiple DHCP servers available on the network, providing additional redundancy and capacity.</p>
<p>If a computer fails to get an IP address from DHCP, it can automatically configure an IP address using the Automatic Private IP Address (APIPA) configuration protocol. In essence, it will assign an IP address in the link-local subnet, that allows it to work on the network without conflicting with anything else. Both IPv4 and IPv6 have set aside a block addresses for this use.</p>
<p>Seth was also gracious enough to provide some sample DHCP configuration files. These were used on CS systems when the department was located in Nichols Hall years ago. Here at the top, you can see the configuration settings for the DHCP lease time. By default, each lease is good for 10 minutes, but clients can request a lease as long as 2 hours (120 minutes, or 7200 seconds). Below that, we can see some default settings for the network, giving the domain name, DNS servers, subnet mask, broadcast addresses, and more for this network.</p>
<p>Here we can see an example for a fixed-address configuration. Whenever a computer contacts this server using that MAC address, it will be assigned the IP address listed below. This is very handy when you have laptops that may come and go on the network. In this way, they are always configured to use DHCP so that the user can use them elsewhere without any problems, but when they are connected to this network they are effectively given a static IP address. Finally, below that we can see a configuration for a simple pool of IP addresses available for automatic configuration.</p>
<p>Of course, this is not a complete configuration file, nor will any of these settings work for your lab assignment. So, you&rsquo;ll need to read the appropriate documentation as well as discover your own network&rsquo;s settings in order to configure your DHCP server.</p>
<p>Let&rsquo;s look at a quick example of how this would look in practice. Here I have configured an Ubuntu VM as directed in Lab 3 to act as a DHCP and DNS server. I also have a second Ubuntu VM acting as our client. Finally, I have disabled the DHCP server in VMware on this network segment.</p>
<p>First, on my server, I&rsquo;m going to start Wireshark so we can capture these packets. I&rsquo;ll also add a filter for <code>bootp</code> to make sure we only see the DHCP server packets. Since BOOTP and DHCP are compatible protocols, this is the way that Wireshark sees the packets.</p>
<p>Next, I&rsquo;m going to boot up the client, which will cause it to request an IP address as it boots. Once it has booted and I&rsquo;ve logged in, I&rsquo;m also going to release my IP address:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo dhclient -r -v</span></span></code></pre></div><p>This should show that it sent a <code>DHCPRELEASE</code> packet to my DHCP server. Then, after waiting a few seconds, we can request a new IP address:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo dhclient -v</span></span></code></pre></div><p>Examining the output, you&rsquo;ll see that we send a <code>DHCPDISCOVER</code> message, then we receive a <code>DHCPOFFER</code> from the server. We can then request an IP using a <code>DHCPREQUEST</code> message, and finally we&rsquo;ll receive a <code>DHCPACK</code> message back from the server acknowledging that request. Here, you&rsquo;ll notice that we send the <code>DHCPREQUEST</code> before we even receive the <code>DHCPOFFER</code>. Since we had an IP previously, we can just go ahead and request it again and see if it works. If so, we&rsquo;ll be on the network a little bit faster, but if not, we can just respond to the <code>DHCPOFFER</code> we receive and continue the original handshake.</p>
<p>Going back to the server, we can clearly see those four packets, as well as the earlier <code>DHCPRELEASE</code> packet. By examining any of those packets, we can see the different bits of information sent from the server to the client and vice-versa.</p>
<p>In addition, by default the DHCP server will log information to the system log, so we can find information about these packets by searching through that log file:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat /var/log/syslog | grep dhcp</span></span></code></pre></div><p>When troubleshooting a DHCP server, it is very helpful to review any error messages present in the system log.</p>
<p>With that information, you should be ready to configure your own DHCP server. As always, if you have any questions or run into issues, please post in the course discussion forums on Canvas. This process can definitely be frustrating the first time you do it, since there is so much new information to read and understand. Don&rsquo;t be afraid to ask for help if you get stuck!</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="dns">DNS</h1>


  
  
<div class="box notices cstyle note">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
  <div class="box-content">

<p>The examples in this video are for an old version of Lab 3, but should be instructive enough to be useful. Read the new Lab 3 assignment carefully and follow its instructions when configuring your system for grading. Some commands are different - see the transcript below for updated commands &ndash;Russ</p>
</div>
</div>

<a href="https://www.youtube.com/watch?v=CN8YPR_X1eU">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><strong><a href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/11-dns-slides/">Slides</a>
</strong></li>
<li><a href="https://en.wikipedia.org/wiki/Domain_Name_System" target="_blank">Domain Name System (DNS)</a>
 on Wikipedia</li>
<li><a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types" target="_blank">List of DNS Record Types</a>
 on Wikipedia</li>
<li><a href="https://www.livinginternet.com/i/iw_dns_history.htm" target="_blank">Domain Name System (DNS) History</a>
 from Living Internet</li>
<li><a href="https://en.wikipedia.org/wiki/BIND" target="_blank">BIND</a>
 on Wikipedia</li>
<li><a href="https://jim.rees.org/apollo-archive/hosts.txt" target="_blank">HOSTS.TXT</a>
 from March 22, 1985</li>
<li><a href="https://en.wikipedia.org/wiki/Root_name_server" target="_blank">Root Name Server</a>
 on Wikipedia</li>
<li><a href="https://www.iana.org/domains/root/files" target="_blank">Root Files</a>
 from IANA</li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-configure-bind-as-a-private-network-dns-server-on-ubuntu-18-04" target="_blank">How To Configure BIND as a Private Network DNS Server on Ubuntu 18.04</a>
 from DigitalOcean (works for 20.04 as well)</li>
<li><a href="https://help.ubuntu.com/community/BIND9ServerHowto" target="_blank">Bind9 Server How-To</a>
 from Ubuntu Community Help Wiki</li>
<li><a href="https://ubuntu.com/server/docs/service-domain-name-service-dns" target="_blank">DNS Configuration</a>
 from Ubuntu Server Guide</li>
<li><a href="http://www.bind9.net/manuals" target="_blank">BIND Manuals</a>
 from bind9.net</li>
</ul>
<h4 id="video-transcript">Video Transcript</h4>
<p>The Domain Name System, or DNS, is another integral part of working with the internet and larger networks today. In this video, we&rsquo;ll cover the history of DNS, how it works, and how to use it in an enterprise organization using the BIND software.</p>
<p>As a quick note, much of the information in this lecture is adapted from information provided by Seth Galitzer, our system administrator here in K-State CS. He created the original slides as part of a guest lecture in this course when it was offered on campus, and was gracious enough to share this information for future versions of the course.</p>
<p>First, let&rsquo;s review some quick history. As you may know, the precursor to today&rsquo;s internet, the ARPANET, was first conceived in 1965. By 1969, the first four nodes of that network were connected. Over the next two decades, ARPANET slowly grew in size, and by 1982, with the introduction of TCP and IP, it exploded in size as various networks joined together to create the internet we know today.</p>
<p>In the early days, they found it would be helpful to have a list of human-readable names for the nodes on the network. In that way, instead of remembering the IP address of a particular server, you could just remember its name and look up the IP address, much like you would look up the phone number of a person or business using a phone book. So, they created a file called <code>hosts.txt</code>, which was hosted by the Stanford Research Institute. In essence, it contained a list of all of the servers on ARPANET, paired with its IP address. Anyone could query that file with a computer name, and get back the IP address of the system.</p>
<p>While it was a useful system, it had some major drawbacks: first, it must be updated manually. At one time, the only way to add a new system to the file was to contact the person in charge of it via telephone. As the file grew larger, it was more and more difficult to maintain consistency and avoid name collisions. Finally, it became very taxing on SRIs system, as each system on the growing internet would download a copy of the <code>hosts.txt</code> file to store locally, sometimes requesting it many times per day to get the very latest version of the file. So, a new system needed to be built to provide this feature.</p>
<p>In 1983, the first version of the Domain Name Service, or DNS, was published as an RFC. It was later finalized in 1987. They proposed creating a distributed system of name servers, as well as a hierarchical, consistent name space for all the systems on the internet. Beyond just working with domain names and IP addresses, they also added the ability for the system to work with many different protocols and data types, hopefully designing it in such a way that it would work well into the future. Thankfully, their design was very successful, and we still use it today.</p>
<p>The domain name space we use today has a hierarchical format, much like this diagram. At the very top of the diagram is the root nameserver. It is responsible for keeping track of the locations of the DNS servers for all top-level domains, or TLDs, in the current domain name space. The original DNS specification calls for 13 root name servers, which is still true today. However, due to advances in technology, there are nearly 1000 redundant root name servers on the internet today, each one a clone of one of the 13 root servers. The file containing information for all of the top-level domains is very small, only about 2 MB, and can be viewed by following the link in the resources section below this video.</p>
<p>Below the root name server is the name server for each chosen top-level domain. For example, these are nameservers for the <code>.com</code>, <code>.org</code>, <code>.edu</code> and other top-level domains. Under each top-level domain are the name servers for each individual domain name, such as <code>yahoo.com</code>, <code>slashdot.org</code>, or <code>k-state.edu</code>. Within each domain, there can be additional levels of delegation, such as the <code>cs.k-state.edu</code> subzone, maintained within the K-State CS department for our internal systems.</p>
<p>With the hierarchical design of the domain name space, it may take a few steps to determine the appropriate IP address for a given domain name. For example, if you wanted to find the IP address of <code>www.wikipedia.org</code>, you might first start by querying the root name server for the location of the <code>.org</code> name server. Then, the <code>.org</code> nameserver could tell you where the <code>wikipedia.org</code> name server is. Finally, when you ask the <code>wikipedia.org</code> name server where <code>www.wikipedia.org</code> is located, it will be able to tell you since it is the authoritative name server for that domain. In practice, often there is a caching DNS server hosted by your ISP that stores previously requested domain names, so you won&rsquo;t always have to talk directly with the root name servers. This helps reduce the overall load across the root servers and makes many queries much faster.</p>
<p>The most commonly used DNS software today is BIND. BIND was originally developed in the 1980s as the first software to fully implement the new DNS standard, and it has been constantly under development ever since. The latest version of BIND is BIND 9, which was first released in 2000, but still consistently gets updates even today.</p>
<p>The DNS specification includes many different types of records. The most commonly used ones are listed here. For example, an <code>A</code> record is used to list a specific IPv4 address for a host name, whereas a <code>CNAME</code> record is used to provide an alias for another domain name. For this lab assignment, you&rsquo;ll be configuring a DNS server using BIND within your network and using several of these record types, so let&rsquo;s take a look at how that works.</p>
<p>Here I have configured an Ubuntu VM as directed in Lab 3 to act as a DHCP and DNS server. I also have a second Ubuntu VM acting as our client. Finally, I have disabled the DHCP server in VMware on this network segment.</p>
<p>First, on my server, I&rsquo;m going to start Wireshark so we can capture these packets. I&rsquo;ll also add a filter for <code>dns</code> to make sure we only see the DNS server packets.</p>
<p>On the client, I have already verified that it is configured to use the other Ubuntu VM as a DNS server. You can see the currently configured DNS servers using this command:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>resolvectl status</span></span></code></pre></div><p>At the bottom of that output, it should show the current DNS server for your ethernet connection. You&rsquo;ll have to press <kbd>Q</kbd> to close the output. To query a DNS record, we can use a couple of different commands. First, we can use the <code>dig</code> command to lookup a DNS name:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>dig ns.cis527.cs.ksu.edu</span></span></code></pre></div><p>Looking at the output received, we can see that we did indeed get the correct IP address. We can also run that command for <code>win.cis527.cs.ksu.edu</code> and <code>ubu.cis527.cs.ksu.edu</code>. Note that the output for <code>ubu.cis527.cs.ksu.edu</code> includes both the <code>CNAME</code> record and the <code>A</code> record.</p>
<p>To perform a reverse lookup, we can use the <code>dig -x</code> command. Since my sample network is using the <code>192.168.40.0/24</code> subnet, I could look up the following IP address:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>dig -x 192.168.40.41</span></span></code></pre></div><p>It should return the <code>PTR</code> record associated with that IP. I can do the same for the IP address ending in <code>42</code> as well.</p>
<p>On a Windows computer, you can use the <code>nslookup</code> command without any additional options to perform both forward and reverse DNS lookups.</p>
<p>Back on the server VM, we should clearly be able to see the DNS packets in Wireshark. Each one gives the type of record requested, and just below it is the response packet with the answer from our DNS server.</p>
<p>With that information, you should be ready to configure your own DNS server. As always, if you have any questions or run into issues, please post in the course discussion forums on Canvas. This process can definitely be frustrating the first time you do it, since there is so much new information to read and understand. Don&rsquo;t be afraid to ask for help if you get stuck!</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="snmp">SNMP</h1>


<a href="https://www.youtube.com/watch?v=JUs543x1BDY">YouTube Video</a>

<!-- 1y5_IR54yb4 -->
<h4 id="resources">Resources</h4>
<ul>
<li><strong><a href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/12-snmp-slides/">Slides</a>
</strong></li>
<li><a href="https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol" target="_blank">Simple Network Management Protocol (SNMP)</a>
 on Wikipedia</li>
<li><a href="http://www.simpleweb.org/ietf/mibs/" target="_blank">MIB Reference</a>
 from SimpleWeb</li>
<li><a href="https://www.alvestrand.no/objectid/1.3.6.1.2.1.html" target="_blank">SNMPv2 MIB Reference</a>
 from Harald T. Alvestrand</li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-an-snmp-daemon-and-client-on-ubuntu-18-04" target="_blank">How to Install and Configure an SNMP Daemon and Client on Ubuntu 18.04</a>
 from DigitalOcean (works for 20.04 as well)</li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-the-net-snmp-tool-suite-to-manage-and-monitor-servers" target="_blank">How to Use The Net-SNMP Tool Suite to Manage and Monitor Servers</a>
 from DigitalOcean (works for 20.04)</li>
<li><a href="https://help.ubuntu.com/community/SNMPAgent" target="_blank">SNMP Agent</a>
 from Ubuntu Community Help Wiki</li>
</ul>
<h4 id="video-transcript">Video Transcript</h4>
<p>In the next few videos, we&rsquo;ll take a look at few other important networking protocols that you may come across as a system administrator. The first one we&rsquo;ll review is the Simple Network Management Protocol, or SNMP.</p>
<p>It was first developed in 1988 as a way for system administrators to query information from a variety of devices on a network, and possibly even update that information as needed. Remember that, in 1988, this was well before the development of the web browsers we know today, so it wasn&rsquo;t as simple as using the web-based configuration interface present on most routers today. However, while most systems today support SNMP, it is primarily used for remote monitoring of networking equipment, and not as much for configuration as it was originally intended.</p>
<p>Over the years, there have been many different versions of SNMP developed. Each one includes a few different features. The first version, SNMPv1, is very basic. While it works well for some things, it only includes a plain-text &ldquo;community string&rdquo; for authentication, resulting in minimal security. SNMPv2 is a significant revision to SNMPv1, and includes a much more robust security model. However, many users found that new model to be overly complex, and a second version called SNMPv2c, for &ldquo;Community&rdquo; was developed without the new security model. Finally, SNMPv3 was developed to include better security, authentication, and a more user-friendly design. It is the only currently accepted standard, though many devices still use the older versions as well.</p>
<p>In SNMP, the data is presented in the form of variables. The variables themselves have a very hierarchical structure, so that similar types of data are grouped together. However, the variables themselves can be difficult to read directly, since each level of the hierarchy is denoted by a number instead of a name.</p>
<p>To help make the variables more readable, SNMP includes a Management Information Base, or MIB, to define what each variable means. Each individual device can define its own MIB, though there are some standards available for common types of data. You can find a couple of those standards linked below the video.</p>
<p>The SNMP protocol itself lists many different types of protocol data units, or PDUs, as part of the standard. For example, the <code>GetRequest</code> PDU is used to query a particular variable on a device, and the <code>Response</code> PDU would be sent back from the device. You&rsquo;ll be able to see several of these PDUs a bit later in the video when we use Wireshark to caputre some SNMP packets.</p>
<hr>
<p>As mentioned earlier, one feature of SNMP is the use of a &ldquo;community string&rdquo; for authentication. In SNMPv1, the community string is a simple text identifier that you can provide along with your request. The server then determines if that community string has access to the variable it requested, and if so, it will return the appropriate response. However, since community strings are sent as plain-text, anyone who was able intercept a packet could find the community string, so it wasn&rsquo;t very secure. In later versions of SNMP, additional security features were added to resolve this issue. In this video, we will see an example of using SNMPv3 with proper security and encryption.</p>
<p>Now that you know a bit about SNMP, let&rsquo;s see a quick example of how it works. Once again, I have configured an Ubuntu VM as directed in Lab 3 to act as an SNMP server, and I&rsquo;ve also configured a second Ubuntu VM to act as an SNMP manager or client.</p>
<p>First, on my server, I&rsquo;m going to start Wireshark so we can capture these packets. Notice that I&rsquo;m capturing packets on the ethernet adapter, since I&rsquo;ll be accessing it from another system. I&rsquo;ll also add a filter for <code>snmp</code> to make sure we only see the SNMP server packets.</p>
<p>Next, on the client system, we can query the data available via SNMP using a couple of different commands. First, I&rsquo;m going to use the simple <code>snmpget</code> command to query a single variable. I&rsquo;ve already configured this system to use a set of authentication credentials stored in a configuration file, which you can do as part of Lab 3&rsquo;s assignment. In this case, I&rsquo;ll query the system&rsquo;s uptime:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>snmpget 192.168.40.41 sysUpTime.0</span></span></code></pre></div><p>In the response, we can clearly see the system&rsquo;s uptime. If we switch back to Wireshark, we can see that it captured some SNMP packets. If we were using SNMP v1, they would be plaintext and we could read the information here clearly. However, since we are now using SNMPv3</p>
<p>To see all the available SNMP variables on your system, you can try the following:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>snmpwalk 192.168.40.41</span></span></code></pre></div><p>This command will result in thousands of lines of output, giving all of the variables available on the system. Looking at Wireshark, there are lots of SNMP packets being transmitted. In fact, each data item in SNMP is sent via its own packet.</p>
<p>Since it can be very difficult to find exactly what you are looking for using the <code>snmpwalk</code> command, you can use <code>grep</code> to search the output for a particular item. For example, to see all of the variables related to TCP, I could do the following:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>snmpwalk 192.168.40.41 | grep TCP-MIB</span></span></code></pre></div><p>If I know the set of variables I&rsquo;d like to query, I can also include them in the <code>snmpwalk</code> command, such as this example:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>snmpwalk 192.168.40.41 TCP-MIB::tcp</span></span></code></pre></div><p>Either way, you should see the variables related to TCP. In the lab assignment, you&rsquo;ll need to query some information about a different set of variables, so you&rsquo;ll have to do some digging on your own to find the right ones.</p>
<p>That&rsquo;s a quick overview of how to use SNMP to query information about your system across the network. If you have any questions about getting it configured on your system, use the course discussion forums on Canvas to ask a question anytime!</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="http">HTTP</h1>


<a href="https://www.youtube.com/watch?v=9QPOQJRcF80">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><strong><a href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/13-http-slides/">Slides</a>
</strong></li>
<li><a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" target="_blank">Hypertext Transfer Protocol (HTTP)</a>
 on Wikipedia</li>
</ul>
<h4 id="video-transcript">Video Transcript</h4>
<p>Next, let&rsquo;s review a couple of application layer protocols. One of the most common of those is the Hypertext Transfer Protocol, or HTTP.</p>
<p>HTTP was developed by Tim Berners-Lee while he worked at CERN in the late 1980s as part of his project to build the World Wide Web. HTTP itself is an application-layer protocol that is built on top of the TCP transport-layer protocol. As with many early application-layer protocols, it is actually a text-based protocol, making it very easy to read and work with manually if desired. HTTP is the protocol used to access webpages on the World Wide Web. In fact, if you look at the address bar of most web browsers, you&rsquo;ll still see <code>http://</code> in front of web addresses, indicating that it is using the HTTP protocol to access that site.</p>
<p>Since HTTP is a text-based protocol, it defines a set of commands and responses to make it easy for the system to understand each packet. The two most common HTTP commands are <code>GET</code> and <code>POST</code>. <code>GET</code> is used to request a webpage from a server, and <code>POST</code> is used to submit information back to the server, usually as part of a form on the website. Other commands are defined, but they are generally not used very often.</p>
<p>When the server responds to a command from a client, it sends along a numerical status code for the response. Some of the common status codes are listed here. For example, <code>200</code> means that the request was accepted properly, whereas <code>404</code> indicates that the requested resource was not fond on the server. You&rsquo;ve probably seen some of these error codes in your web browser from time to time.</p>
<p>As I mentioned earlier, HTTP is a text-based protocol. That means, if you are able to type quickly enough, you can use a text-based program such as Telnet to actually send queries directly to a web server. This image shows an HTTP request and response sent using Telnet to the main Wikipedia server.</p>
<p>Let&rsquo;s see if we can recreate this connection on our own system. Once again, I&rsquo;m going to use my Ubuntu server configured as directed for Lab 3. I&rsquo;m also going to start Wireshark so we can capture these packets. I&rsquo;ll add a filter for <code>http</code> to make sure we only see the HTTP packets.</p>
<p>To initiate an HTTP connection, we&rsquo;ll use the <code>telnet</code> command to connect to a server on port 80:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>telnet cs.ksu.edu <span style="color:#ae81ff">80</span></span></span></code></pre></div><p>That should connect you to the server. Once connected, you can request the homepage using this HTTP command:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span><span style="color:#a6e22e">GET</span> /index.html <span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.0</span>
</span></span><span style="display:flex;"><span>Host<span style="color:#f92672">:</span> <span style="color:#ae81ff">cs.ksu.edu</span></span></span></code></pre></div><p>Once you leave a blank line, the server should respond. In this case, you should get the following headers in your response:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span><span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span> <span style="color:#ae81ff">301</span> <span style="color:#a6e22e">Moved Permanently</span>
</span></span><span style="display:flex;"><span>Date<span style="color:#f92672">:</span> <span style="color:#ae81ff">Wed, 05 Sep 2018 19:47:12 GMT</span>
</span></span><span style="display:flex;"><span>Server<span style="color:#f92672">:</span> <span style="color:#ae81ff">Apache/2.4.25 (Debian)</span>
</span></span><span style="display:flex;"><span>Location<span style="color:#f92672">:</span> <span style="color:#ae81ff">http://www.cs.ksu.edu/index.html</span>
</span></span><span style="display:flex;"><span>Content-Length<span style="color:#f92672">:</span> <span style="color:#ae81ff">316</span>
</span></span><span style="display:flex;"><span>Connection<span style="color:#f92672">:</span> <span style="color:#ae81ff">close</span>
</span></span><span style="display:flex;"><span>Content-Type<span style="color:#f92672">:</span> <span style="color:#ae81ff">text/html; charset=iso-8859-1</span></span></span></code></pre></div><p>Looking at the response, you can see that the status code is <code>301 Moved Permanently</code>, letting me know that the page is available at a different location. A little bit later, it gives the new location as <code>http://www.cs.ksu.edu/index.html</code>. So, I&rsquo;ll have to query that server instead.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>telnet www.cs.ksu.edu <span style="color:#ae81ff">80</span></span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span><span style="color:#a6e22e">GET</span> /index.html <span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.0</span>
</span></span><span style="display:flex;"><span>Host<span style="color:#f92672">:</span> <span style="color:#ae81ff">www.cs.ksu.edu</span></span></span></code></pre></div><p>Once I do that, I should now get a proper web page as the response:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span><span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span> <span style="color:#ae81ff">200</span> <span style="color:#a6e22e">OK</span>
</span></span><span style="display:flex;"><span>Date<span style="color:#f92672">:</span> <span style="color:#ae81ff">Wed, 05 Sep 2018 19:49:59 GMT</span>
</span></span><span style="display:flex;"><span>Server<span style="color:#f92672">:</span> <span style="color:#ae81ff">Apache/2.4.25 (Debian)</span>
</span></span><span style="display:flex;"><span>Accept-Ranges<span style="color:#f92672">:</span> <span style="color:#ae81ff">bytes</span>
</span></span><span style="display:flex;"><span>Vary<span style="color:#f92672">:</span> <span style="color:#ae81ff">Accept-Encoding</span>
</span></span><span style="display:flex;"><span>Connection<span style="color:#f92672">:</span> <span style="color:#ae81ff">close</span>
</span></span><span style="display:flex;"><span>Content-Type<span style="color:#f92672">:</span> <span style="color:#ae81ff">text/html</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">&lt;!DOCTYPE html&gt;</span>
</span></span><span style="display:flex;"><span>&lt;<span style="color:#f92672">html</span> <span style="color:#a6e22e">lang</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;en-US&#34;</span>&gt;&lt;<span style="color:#f92672">head</span>&gt;
</span></span><span style="display:flex;"><span>...</span></span></code></pre></div><p>Going back to Wireshark, we should clearly see those HTTP packets. You can see each request packet, followed by the response including the status code. If you examine the contents of the packets, you&rsquo;ll see that it exactly matches what we were able to receive using <code>telnet</code>. It&rsquo;s really that simple.</p>
<p>Now, let&rsquo;s do one more quick example, just to see one of the weaknesses of the HTTP protocol. Some early websites required authentication using the HTTP protocol. However, unless you use a security layer such as TLS, those packets would not be encrypted whatsoever, and anyone able to capture the packet could decode the username and password. Let&rsquo;s see what HTTP authentication would look like using <code>telnet</code>.</p>
<p>First, we&rsquo;ll have to create a base64 encoding of our username and password. These are the same credentials used in the lab assignment:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo -n cis527:cis527_apache | base64 -</span></span></code></pre></div><p>The output should be <code>Y2lzNTI3OmNpczUyN19hcGFjaGU=</code>, which is what we&rsquo;ll use for the next command.</p>
<p>Now, let&rsquo;s use <code>telnet</code> to connect to our secured page:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>telnet people.cs.ksu.edu <span style="color:#ae81ff">80</span></span></span></code></pre></div><div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span><span style="color:#a6e22e">GET</span> /~russfeld/test/ <span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.0</span>
</span></span><span style="display:flex;"><span>Host<span style="color:#f92672">:</span> <span style="color:#ae81ff">people.cs.ksu.edu</span>
</span></span><span style="display:flex;"><span>Authorization<span style="color:#f92672">:</span> <span style="color:#ae81ff">Basic Y2lzNTI3OmNpczUyN19hcGFjaGU=</span></span></span></code></pre></div><p>If it works correctly, you should receive a response like the following:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span><span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span> <span style="color:#ae81ff">200</span> <span style="color:#a6e22e">OK</span>
</span></span><span style="display:flex;"><span>Date<span style="color:#f92672">:</span> <span style="color:#ae81ff">Wed, 05 Sep 2018 20:06:10 GMT</span>
</span></span><span style="display:flex;"><span>Server<span style="color:#f92672">:</span> <span style="color:#ae81ff">Apache/2.4.10 (Debian)</span>
</span></span><span style="display:flex;"><span>Last-Modified<span style="color:#f92672">:</span> <span style="color:#ae81ff">Wed, 17 Feb 2016 16:48:27 GMT</span>
</span></span><span style="display:flex;"><span>ETag<span style="color:#f92672">:</span> <span style="color:#ae81ff">&#34;5e-52bfa04e3af09&#34;</span>
</span></span><span style="display:flex;"><span>Accept-Ranges<span style="color:#f92672">:</span> <span style="color:#ae81ff">bytes</span>
</span></span><span style="display:flex;"><span>Content-Length<span style="color:#f92672">:</span> <span style="color:#ae81ff">94</span>
</span></span><span style="display:flex;"><span>Vary<span style="color:#f92672">:</span> <span style="color:#ae81ff">Accept-Encoding</span>
</span></span><span style="display:flex;"><span>Connection<span style="color:#f92672">:</span> <span style="color:#ae81ff">close</span>
</span></span><span style="display:flex;"><span>Content-Type<span style="color:#f92672">:</span> <span style="color:#ae81ff">text/html</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&lt;<span style="color:#f92672">html</span>&gt;
</span></span><span style="display:flex;"><span>&lt;<span style="color:#f92672">head</span>&gt;
</span></span><span style="display:flex;"><span>	&lt;<span style="color:#f92672">title</span>&gt;Congrats!&lt;/<span style="color:#f92672">title</span>&gt;
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#f92672">head</span>&gt;
</span></span><span style="display:flex;"><span>&lt;<span style="color:#f92672">body</span>&gt;
</span></span><span style="display:flex;"><span>Congrats! You did it!
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#f92672">body</span>&gt;
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#f92672">html</span>&gt;</span></span></code></pre></div><p>So, even though it looks like the username and password are encrypted, they are easily deciphered using any base64 decoding program. As part of the lab assignment, you&rsquo;ll capture an authentication packet just like this one in Wireshark.</p>
<p>This is just a quick introduction to HTTP. There are many interesting features in the protocol, and they are easy to explore by simply capturing packets with Wireshark while you use a web browser to surf the World Wide Web. I encourage you to do just that to get a bit more experience with HTTP.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="email-protocols">Email Protocols</h1>


<a href="https://www.youtube.com/watch?v=lcg43SAJv5Q">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><strong><a href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/14-email-protocols-slides/">Slides</a>
</strong></li>
<li><a href="https://en.wikipedia.org/wiki/Email" target="_blank">Email</a>
 on Wikipedia</li>
<li><a href="https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol" target="_blank">Simple Mail Transfer Protocol (SMTP)</a>
 on Wikipedia</li>
<li><a href="https://en.wikipedia.org/wiki/Post_Office_Protocol" target="_blank">Post Office Protocol (POP3)</a>
 on Wikipedia</li>
<li><a href="https://en.wikipedia.org/wiki/Internet_Message_Access_Protocol" target="_blank">Internet Message Access Protocol (IMAP)</a>
 on Wikipedia</li>
<li><a href="https://www.digitalocean.com/community/tutorials/why-you-may-not-want-to-run-your-own-mail-server" target="_blank">Why You May Not Want to Run Your Own Mail Server</a>
 from DigitalOcean</li>
</ul>
<h4 id="video-transcript">Video Transcript</h4>
<p>In this video, we&rsquo;ll look at one more set of application layer protocols, the ones for sending and receiving electronic mail, or email.</p>
<p>Email was developed in the early days of the ARPANET, and was originally built as an extension to the existing File Transfer Protocol or FTP. Using these email protocols, a user on one system could send a message to a user on another system. Email was originally designed to be a text-only format, but the later introduction of the Multipurpose Internet Mail Extensions, or MIME, allowed emails to include additional content such as HTML markup, images, and more.</p>
<p>To send and receive email across the internet, there are a number of protocols involved. First, the Simple Mail Transfer Protocol (SMTP) is used to send mail from an email client to a server, and then between the servers until it reaches its desired recipient. Once there, the recipient can use either the Post Office Protocol (POP3), the Internet Message Access Protocol (IMAP), Microsoft&rsquo;s Exchange ActiveSync, or any number of webmail clients to actually view the email.</p>
<p>On an email server itself, there are several pieces of software involved in sending and receiving email. First, the Mail Transfer Agent (MTA) is responsible for SMTP connections, and is primarily used to send and receive email from other email servers. Next, the Mail Delivery Agent (MDA) will receive email from the MTA destined for users on this server, and will route it to the appropriate mailbox. Finally, there are any number of ways to get the email from the mailbox to the user, using the POP3, IMAP, or any number of other protocols. Or, as is often the case today, the user can simply view the email in a web browser, using a webmail client.</p>
<p>To see how email is routed through the internet, here is a nice diagram from Wikipedia showing the process. When Alice wants to send an email to Bob, she must first compose the email and send it to her local MTA using the SMTP protocol. Then, the MTA will use a DNS lookup to find the MX entry for Bob&rsquo;s email domain, which is <code>b.org</code> in this example. Then, the MTA can send that email to Bob&rsquo;s MTA, which will then pass it along to the MDA on that system, placing it in Bob&rsquo;s mailbox. Finally, Bob can then use a protocol such as POP3 to read the email from his mailbox onto his computer.</p>
<p>As with many other application layer protocols, several of the core email protocols are text-based as well, and can easily be done by hand using <code>telnet</code>. This slide shows what it would look like to use <code>telnet</code> to receive email using the POP3 protocol. However, most email servers today require the use of a secure protocol when accessing an email account, so it is difficult to perform this activity today.</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cis527@cis527russfeldpuppet:~$ telnet mail.servergrove.com <span style="color:#ae81ff">110</span>
</span></span><span style="display:flex;"><span>Trying 69.195.222.232...
</span></span><span style="display:flex;"><span>Connected to mail.servergrove.com.
</span></span><span style="display:flex;"><span>Escape character is <span style="color:#e6db74">&#39;^]&#39;</span>.
</span></span><span style="display:flex;"><span>+OK POP3 ready
</span></span><span style="display:flex;"><span>USER test@beattieunioncemetery.org
</span></span><span style="display:flex;"><span>+OK
</span></span><span style="display:flex;"><span>PASS uns3cur3
</span></span><span style="display:flex;"><span>+OK logged in.
</span></span><span style="display:flex;"><span>STAT
</span></span><span style="display:flex;"><span>+OK <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">5580</span>
</span></span><span style="display:flex;"><span>RETR <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>+OK <span style="color:#ae81ff">4363</span> octets follow.
</span></span><span style="display:flex;"><span>Received: <span style="color:#f92672">(</span>qmail <span style="color:#ae81ff">11929</span> invoked from network<span style="color:#f92672">)</span>; <span style="color:#ae81ff">26</span> Feb <span style="color:#ae81ff">2016</span> 16:16:14 +0000
</span></span><span style="display:flex;"><span>Received-SPF: none <span style="color:#f92672">(</span>no valid SPF record<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Received: from mx-mia-1.servergrove.com <span style="color:#f92672">(</span>69.195.198.246<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  by sg111.servergrove.com with SMTP; <span style="color:#ae81ff">26</span> Feb <span style="color:#ae81ff">2016</span> 16:15:43 +0000
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>DELE <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>+OK message <span style="color:#ae81ff">2</span> deleted
</span></span><span style="display:flex;"><span>QUIT
</span></span><span style="display:flex;"><span>+OK Bye-bye.</span></span></code></pre></div><p>However, many SMTP servers still support sending email via an unsecured connection. This is mainly because there are several older devices such as printers, copiers, network devices, and security devices that are all designed to send alerts via email. Those older devices are difficult if not impossible to upgrade, so many system administrators are forced to use an unsecured SMTP server to accept those notification emails. So, we can use one of those to perform this quick test and see how it works.</p>
<p>For this example, I will connect to the K-State CS Linux servers, as the server we are using will only accept emails from a limited number of systems, including these servers. In addition, it will only accept email sent to a limited number of domains. Both of these protections are in place to limit the amount of unsolicited SPAM email that could be sent using this server.</p>
<p>First, I&rsquo;ll use <code>telnet</code> to connect to the email server on port 25, the well-known port for SMTP:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>telnet smtp.cs.ksu.edu <span style="color:#ae81ff">25</span></span></span></code></pre></div><p>Then, I&rsquo;ll need to establish a connection with it, send my email, and close the connection. To make it easier to see below, I&rsquo;ve prefixed the messages from the server and my telnet client with <code>###</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">### Trying 129.130.10.29...</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">### Connected to daytona.cs.ksu.edu.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">### Escape character is &#39;^]&#39;.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">### 220 daytona.cis.ksu.edu ESMTP Postfix (Debian/GNU)</span>
</span></span><span style="display:flex;"><span>HELO daytona.cs.ksu.edu
</span></span><span style="display:flex;"><span><span style="color:#75715e">### 250 daytona.cis.ksu.edu</span>
</span></span><span style="display:flex;"><span>MAIL FROM: testuser@ksu.edu
</span></span><span style="display:flex;"><span><span style="color:#75715e">### 250 2.1.0 Ok</span>
</span></span><span style="display:flex;"><span>RCPT TO: russfeld@ksu.edu
</span></span><span style="display:flex;"><span><span style="color:#75715e">### 250 2.1.5 Ok</span>
</span></span><span style="display:flex;"><span>DATA
</span></span><span style="display:flex;"><span><span style="color:#75715e">### 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</span>
</span></span><span style="display:flex;"><span>From: <span style="color:#e6db74">&#34;Russell Feldhausen&#34;</span>
</span></span><span style="display:flex;"><span>To: <span style="color:#e6db74">&#34;Test&#34;</span>
</span></span><span style="display:flex;"><span>Date: Fri, <span style="color:#ae81ff">6</span> September <span style="color:#ae81ff">2018</span> 10:00:00 -0700
</span></span><span style="display:flex;"><span>Subject: Test Message
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>This is a test! Hope it Works!
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.
</span></span><span style="display:flex;"><span><span style="color:#75715e">### 250 2.0.0 Ok: queued as 827D23FDD1</span>
</span></span><span style="display:flex;"><span>QUIT
</span></span><span style="display:flex;"><span><span style="color:#75715e">### 221 2.0.0 Bye</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">### Connection closed by foreign host.</span></span></span></code></pre></div><p>Once I have completed that process, I should receive the email in my inbox shortly. You&rsquo;ll notice that there are many things interesting about this email. First, my email client reports the correct date and time that it was received, but at the top of the email itself it gives a different timestamp for when it was sent. Additionally, even though I used my own email address as the recipient, in the email header I listed the name &ldquo;Test&rdquo; as the recipient, which is what appears in the email client.</p>
<p>I hope that this example clearly demonstrates how easy it is to spoof any part of an email. The email servers and protocols themselves don&rsquo;t enforce many rules at all, so it is easy to abuse the system, leading to the large amount of SPAM email we receive on a daily basis. However, I still find it fascinating to see behind the curtains a little at how these protocols are actually structured and how easy it is to work with them.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="security">Security</h1>


<a href="https://www.youtube.com/watch?v=1NpoTIbiQIo">YouTube Video</a>

<h4 id="resources">Resources</h4>
<ul>
<li><strong><a href="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/15-security-slides/">Slides</a>
</strong></li>
<li><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank">Transport Layer Security (TLS)</a>
 on Wikipedia</li>
<li><a href="https://hpbn.co/transport-layer-security-tls/" target="_blank">Transport Layer Security (TLS)</a>
 from High Performance Browser Networking on O&rsquo;Reilly</li>
<li><a href="https://ubuntu.com/server/docs/security-firewall" target="_blank">Firewall</a>
 on Ubuntu Server Guide</li>
<li><a href="https://wiki.ubuntu.com/UncomplicatedFirewall" target="_blank">Uncomplicated Firewall</a>
 on Ubuntu Wiki</li>
<li><a href="https://www.esecurityplanet.com/network-security/finetune-and-optimize-firewall-rules.html" target="_blank">Fine-tuning Firewall Rules: 10 Best Practices</a>
 from eSecurity Planet</li>
</ul>
<h4 id="video-transcript">Video Transcript</h4>
<p>Lastly, it is very important to take a few minutes to discuss some security concerns related to networking. While this isn&rsquo;t a security course, it is vital for system administrators to understand the security tradeoffs of any system they configure.</p>
<p>When dealing with networks, there are a few security concepts to keep in mind. First and foremost is your firewall. On any system you work with, you should ensure that the firewall is properly enabled. It should also be configured to only allow incoming connections on the smallest set of ports that will allow the server to function. In other words, you should only allow ports for software you are planning to use on the server, and all other ports should be blocked. This follows the security concept of &ldquo;Principle of Least Privilege,&rdquo; where you only allow the smallest number of permissions required for the system to function.</p>
<p>Similarly, many larger networks should also employ some network monitoring software to scan for unwanted network traffic. While a firewall helps guard against incoming connections, it cannot detect a malicious outgoing connection from a compromised system. A proper network monitoring system could help you detect that breach and stop it before it becomes a larger issue.</p>
<p>For smaller networks and home users, simply installing and using a NAT router offers a significant layer of protection with minimal hassle. A NAT router will block all incoming traffic by default, unless you or one of your systems requests a port to be opened for a specific use. While it isn&rsquo;t a perfect system, in general this is much better than connecting a computer directly to the public internet itself.</p>
<p>Lastly, for any network connections, you should consider using some form of encryption and authentication on the connection. By doing so, you can be sure that you are connecting to the correct system on the other end, and that no one else can intercept your communication once it is established. Thankfully, there are many ways to accomplish this.</p>
<p>Many systems today use Transport Layer Security, or TLS, to help secure their network connections. TLS was formerly known as SSL, and while many users may use the terms interchangeably, technically SSL is an obsolete protocol that was replaced by TLS many years ago, so TLS is the proper way to refer to it today. The TLS name can also be a bit misleading, because it doesn&rsquo;t truly reside in the transport layer. Instead, it is typically above the transport layer, but below the top three application layers of the 7 layer OSI model. Many diagrams show it as part of the session layer, which is a pretty good way to think of it.</p>
<p>In essence, what TLS does is perform a handshake protocol after the TCP connection has been established between the two systems, but before any application data is sent or received. This diagram shows what a TLS handshake entails. The blue boxes at the top are the TCP connection being established, followed by the tan boxes giving the steps of the TLS handshake protocol. During that process, the two systems exchange security certificates, agree on an encryption algorithm, and generate a shared encryption key that is known only to those two systems. The sender and recipient can confirm each other&rsquo;s identity based on a &ldquo;chain of trust&rdquo; for the certificates presented; in essence, they look to see if the certificate is signed by someone they trust, in which case they can also trust the certificate itself. Once that is done, it then cedes control to the application, which can then start sending and receiving packets.</p>
<p>When a packet is transmitted, the TLS layer will encrypt the packet so that it cannot be read by others. It will also include a second part of the message, called a message authentication code or MAC, that will help detect if the encrypted packet is altered in any way.</p>
<p>Many protocols today use TLS by default, including HTTP. You&rsquo;ve probably seen the <code>https</code> protocol in your web browser many times. That simply means that your browser is using TLS to communicate with the web server. In addition, many browsers will show information about the certificate presented by the web server, and will alert you if the certificate is untrusted.</p>
<p>This is a very brief overview of the security concerns involved in a networked world. I encourage you to consider taking additional courses in cyber security if you are interested in learning the details of how these systems are implemented. In any case, you should always be thinking about security as you configure your systems to connect to a network.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="bind-troubleshooting">Bind Troubleshooting</h1>

<p>As I was reworking this lab for the Summer 2020 semester, I ran into a few issues getting my own bind9 server to work. In doing so, I ended up taking some great screenshots of common misconfigurations of bind9 and the related output from using the <code>dig</code> command to diagnose the issue. I figured it would be helpful to share those screenshots here to give you a nice guide to some common errors you may encounter when working with bind9.</p>
<h2 id="incorrect-screenshots">Incorrect Screenshots</h2>
<h4 id="bad-ptr-response">Bad PTR Response</h4>
<p>
<a href="#image-c8f33c778a347117588612395ccebfc8" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-badresponse.png" alt="192.168.40.41 bad" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-c8f33c778a347117588612395ccebfc8">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-badresponse.png" alt="192.168.40.41 bad" class="lightbox-image" loading="lazy">
</a></p>
<p>In this screenshot, I attempted to do a reverse lookup of <code>192.168.40.41</code>, which should resolve to <code>ns.cis527russfeld.cs.ksu.edu</code>. This test was done from the machine with that IP address. Unfortunately, my server was misconfigured, and the reverse zone file was not properly included (the path in my <code>named.conf.local</code> file had a typo, to be exact). Since that file was not availble, my system returned the response from it&rsquo;s local DNS information, showing that the IP address <code>192.168.40.41</code> belongs to <code>cis527U-russfeld.</code>, which is the name of the actual computer and not its name in the DNS system. This can happen if you try to request information about the local system and the DNS server does not contain the correct information.</p>
<h4 id="no-ptr-response">No PTR Response</h4>
<p>
<a href="#image-0fcfddc3edf3f289067aa6581bb755cd" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-noresponse.png" alt="192.168.40.42 no response" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-0fcfddc3edf3f289067aa6581bb755cd">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-noresponse.png" alt="192.168.40.42 no response" class="lightbox-image" loading="lazy">
</a></p>
<p>With the same misconfiguration as described above, when I query a different system, such as <code>192.168.40.42</code>, I instead get an empty response as shown here. This is the usual situation if the DNS server is misconfigured and the PTR record cannot be found. If the output of <code>dig</code> is missing an answer section, it usually indicates that the lookup failed.</p>
<h4 id="missing-period">Missing Period</h4>
<p>
<a href="#image-10dae1f73088a7e23e4536b0857837d2" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-reversebad1.png" alt="192.168.40.41 no period" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-10dae1f73088a7e23e4536b0857837d2">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-reversebad1.png" alt="192.168.40.41 no period" class="lightbox-image" loading="lazy">
</a></p>
<p>So, I corrected my error and restarted my bind9 server, and once again tried to query one of my reverse lookup addresses. However, in this case, I <em>did</em> get a response from the DNS server, but it was incorrect. The address returned when I queried <code>192.168.40.42</code> as <code>windows.cis527russfeld.cs.ksu.edu.40.168.192.in-addr.arpa</code>, which is not what I wanted. This can happen when you forget to add the <strong>all important period</strong> at the end of an entry in your zone file.</p>
<p>
<a href="#image-c8c485e27acf8b52615190042c7888f1" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-period.png" alt="Period" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-c8c485e27acf8b52615190042c7888f1">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-period.png" alt="Period" class="lightbox-image" loading="lazy">
</a></p>
<p>That one, right there. If you forget that one, the bind9 DNS server will automatically append a whole bunch of domain information after the address. Sometimes we want that, but in this case, we don&rsquo;t. So, be <em>very</em> careful and don&rsquo;t forget the periods.</p>
<h4 id="dns-caching">DNS Caching</h4>
<p>
<a href="#image-822985f7e8f3f7443b3059bb20b8b487" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-flushcache.png" alt="192.168.40.41 fail after fix" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-822985f7e8f3f7443b3059bb20b8b487">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-flushcache.png" alt="192.168.40.41 fail after fix" class="lightbox-image" loading="lazy">
</a></p>
<p>In this screenshot, I had just resolved the error above and restarted my bind9 server to load the newly changed files. Then, I once again used <code>dig</code> to query <code>192.168.40.42</code>, expecting to see the correct output. Instead, I still received the incorrect output as seen in the screenshot above. This is a very common problem!</p>
<p>There can be a couple of causes of this issue. First, whenever you update a zone file, don&rsquo;t forget to change the serial value to a larger number. The DigitalOcean guide just has you start with 2 and go to 3 and so on. I like to use the date, followed by a serial for that day. So, I would use a serial such as <code>202005061</code> for the first update made on May 6th, 2020 (2020-05-06).</p>
<p>Secondly, even if you remember to do that, many modern systems employ some form of <em>DNS caching</em> that stores the responses from previous queries. Both Ubuntu and Windows do this automatically. So, you may also have to clear your DNS cache to make sure it is properly querying the server. On Ubuntu, use <code>sudo resolvectl flush-caches</code> and on Windows use <code>ipconfig /flush-dns</code>.</p>
<p>
<a href="#image-9b564fde280ce732bd633e4e387bcc4e" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-flushcache2.png" alt="192.168.40.41 fail after fix" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-9b564fde280ce732bd633e4e387bcc4e">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-flushcache2.png" alt="192.168.40.41 fail after fix" class="lightbox-image" loading="lazy">
</a></p>
<p>Immediately after flushing the DNS cache, I was able to perform the query again and get the correct result.</p>
<h2 id="correct-screenshots">Correct Screenshots</h2>
<p>Below are screenshots showing correct output for various <code>dig</code> commands. You may use these screenshots to help in your debugging process. To take these screenshots, I updated the static IP address configuration for the Ubuntu Server to use it&rsquo;s own IP address <code>192.168.40.41</code> as the only DNS server.</p>
<h4 id="correct-a-records">Correct A Records</h4>
<p>
<a href="#image-50145cf96fc40e4983c0854e4e5a317e" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-dig1.png" alt="ns.cis527russfeld.cs.ksu.edu" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-50145cf96fc40e4983c0854e4e5a317e">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-dig1.png" alt="ns.cis527russfeld.cs.ksu.edu" class="lightbox-image" loading="lazy">
</a>

<a href="#image-62b0714ce1af7297858794647f5e5820" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-dig2.png" alt="windows.cis527russfeld.cs.ksu.edu" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-62b0714ce1af7297858794647f5e5820">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-dig2.png" alt="windows.cis527russfeld.cs.ksu.edu" class="lightbox-image" loading="lazy">
</a></p>
<h4 id="correct-cname-records">Correct CNAME Records</h4>
<p>
<a href="#image-b02b5543690a199b15ff9109ed95a6f5" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-dig3.png" alt="ubuntu.cis527russfeld.cs.ksu.edu" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-b02b5543690a199b15ff9109ed95a6f5">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-dig3.png" alt="ubuntu.cis527russfeld.cs.ksu.edu" class="lightbox-image" loading="lazy">
</a></p>
<h4 id="correct-ptr-record">Correct PTR Record</h4>
<p>
<a href="#image-3e6905d0fcc29b7408afdac91b4a594b" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-reverse1.png" alt="192.168.40.41" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-3e6905d0fcc29b7408afdac91b4a594b">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-reverse1.png" alt="192.168.40.41" class="lightbox-image" loading="lazy">
</a></p>
<h4 id="correct-recursive-lookup-outside-our-dns-server">Correct Recursive Lookup (Outside our DNS Server)</h4>
<p>
<a href="#image-2027b1d5430279dfdeb9a4ac971a0397" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-recurse.png" alt="Recursive Lookup" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-2027b1d5430279dfdeb9a4ac971a0397">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/17-bind-troubleshooting/../../images/lab3-recurse.png" alt="Recursive Lookup" class="lightbox-image" loading="lazy">
</a></p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="lab-3-demo">Lab 3 Demo</h1>


<a href="https://www.youtube.com/watch?v=1qBSikLyIRE">YouTube Video</a>

<h4 id="video-transcript">Video Transcript</h4>
<p>Okay, so I&rsquo;m going to try and talk through a model solution version of lab three and give you some advice on how to go about this lab. And also how to verify that you got this lab configured and working properly. So the first thing we&rsquo;re going to do is we&rsquo;re going to look at our IP address. So I&rsquo;m going to go to the Edit menu in VMware and then choose virtual network editor. And in the virtual network editor, we&rsquo;re going to find our NAT network. And we&rsquo;ll notice that it has a subnet address of <code>192.168.40.0</code>, yours will probably be similar, but it may have a different third octet right here. It&rsquo;s usually randomly assigned by VMware when you install it. Mine is dot 40. Yours might be different, so we need to make note of that IP address. The other thing in here we can see is this checkmark the use local DHCP service; once you get done with task four and have your DHCP server running, you&rsquo;ll want to go in here and uncheck this box, you have to click this change settings button to give it admin access. But then you can uncheck this box to turn off VMware&rsquo;s DHCP service, so you can use your own. So remember we have <code>192.168.40</code>.</p>
<p>So up here in Ubuntu, we want to set a static IP address in that same range. So in my settings, if I go in here and look at IPv4, you can notice that I&rsquo;ve set an IP address <code>192.168.40.41.</code> And the dot 41 is what the assignment says that we&rsquo;re going to use for our Ubuntu server. We also need to set the gateway. In VMware, it uses a default gateway of dot two inside of your network. The reason it does this is dot one is usually used by your home routers and some other services. And so to avoid any conflicts, VMware has set it to dot two. We also have the netmask of <code>255.255.255.0</code>. That&rsquo;s pretty standard. We talked about the lecture. And then you notice that right now I&rsquo;ve actually set it to refer to itself as a DNS server. Originally in the lab, you&rsquo;ll probably set this to dot two, so that you still have working internet. But once you get your DNS server working, you can set it to dot 41. So that actually refers to itself for its DNS. So we&rsquo;ll go ahead and apply this once you apply it, you can turn it off and turn it back on to make sure it&rsquo;s applied.</p>
<p>This is the only VM in this lab that you need to set a static IP address on. I&rsquo;ve seen some students try and set static IPs on the Ubuntu and the Windows, you don&rsquo;t need to do that. For testing of your DNS server, you can set a static DNS entry temporarily. But the idea is by the time you get done with lab three these to your Ubuntu client and your Windows client should both be getting its IP address from the DHCP server on your Ubuntu server.</p>
<p>Okay, so once we have that set, we can confirm our IP address is correct by doing <code>ip addr show</code> that will show us our IP address. And we&rsquo;ll notice right here that we see the 40 dot 41 IP address. We also need to keep in mind this <code>ens33</code>. This is the name of the interface that this is connected on. And so in the DHCP setup, you&rsquo;ll need to go in and set a file that defines which interfaces to listen on. This is the interface we want to listen on. But for the DNS server, we actually tell it the IP address that we want to listen on. And so we&rsquo;ll need this IP address in our DNS server configuration.</p>
<p>So once we have our DNS server up and running, we&rsquo;ll also need to make sure that we allow it through the firewall, I&rsquo;ll leave that up to you, you can look up what ports you need and how to allow that through the firewall.</p>
<p>But if it&rsquo;s working, we can use the <code>dig</code> command followed by an at symbol and the IP address of our system. And so what this does is this tells <code>dig</code> to ignore any DNS settings we have on our system and query this particular server, and we&rsquo;re going to query for <code>ns.cis527russfeld.cs.ksu.edu</code>. And when we do that, we get this response. Here, just to help. Let me put this command back up here again. So I&rsquo;m doing <code>dig</code> at the IP address of my server. And you can do this either on the server or on the client. And then I&rsquo;m giving it the name of a server that I want to look up in our DNS configuration. And so if I run this command, in this answer section, I should get back that this name goes to this IP address, which is correct. So that&rsquo;s how we look up an entry on our forward zone.</p>
<p>If we went to look up an entry in our reverse zone, instead of doing the name, we do dash x, and then we would put in an IP address, I&rsquo;m going to put in the IP address <code>42</code> which when we do this, it will show our answer section is we&rsquo;re looking up <code>42.40.168.192.in-addr.arpa</code>, which is the reverse lookup IP address. And then we are getting our Windows Server back.</p>
<p>So to really check to see if your DNS server is working, those are the two commands you need. You just need to be able to use <code>dig</code> at your server&rsquo;s IP address, and then dash x for reverse lookup, or for forward lookup, you just put in a domain name. You can also test your forwarding. If you want to make sure your forwarding is working, I can <code>dig</code> that server and just look for <code>www.yahoo.com</code> for example, and I can get responses from that. I can also look up the reverse. If I want to look up a reverse, I can do a reverse for <code>208.67.222.222</code> which is one of the OpenDNS resolvers. So this is pretty much confirmed that our DNS server is working on the server.</p>
<p>If you want to check it from one of your clients, you can switch over to your client, and here on the client I can run those exact same commands. So if I do <code>dig</code> at my server IP address, and this is without setting any static DNS entries, this is just telling <code>dig</code> to query this IP. And then if I do my address here, then I can run it. And once again, we&rsquo;re getting that answer. And so this is how you can check, you can test your DNS configuration before you have DHCP working, you don&rsquo;t have to change anything on your client, you just use the at symbol in your <code>dig</code> command to tell it to query that particular DNS server for this entry.</p>
<p>So that&rsquo;s the DNS parts. If that doesn&rsquo;t work, there&rsquo;s a really good guide on DNS troubleshooting that talks you through a lot of different things you might run into, Be especially careful of your periods and your spacing in your DNS configuration files. All of that is really important. There&rsquo;s also a really good discussion on Piazza right now about the number of octets in your reverse zone file. In the dot local file, you can have three octets and then you only need one octet in your zone file. If that doesn&rsquo;t make sense post on Piazza, let us know. We can try and clarify that.</p>
<p>Okay, so the second part is your DHCP server. And the DHCP server configuration is pretty simple. However, I&rsquo;m going to call out one thing real quick. If I go to <code>/etc/default</code>, you&rsquo;ll notice there&rsquo;s a file in here that might exist. That&rsquo;s, whoops. Helps if I go to the server. I go to the server. And then looking here, you&rsquo;ll see there is a file called <code>isc-dhcp-server</code>. And so in this file, it has some entries. And depending on what guide you read, sometimes you will need to define an interface right here that your DHCP server could listen on. Mine I didn&rsquo;t need to define that, it just worked. But in a lot of cases, you might need to define that. So this is where you would put that is that ens33 that we saw earlier.</p>
<p>So once you get your DHCP server running, you can start it, I&rsquo;m just going to restart mine. So I restart that. And now your server should be running. If you want to check, a good way to check is you can do <code>sudo cat /var/log/syslog</code>. And we&rsquo;ll look at the very end of our syslog. These last few entries. And we can see here that our, that our DHCP server started up; it read its config file. And then it will say things like listening and sending. And as long as you see that it&rsquo;s listening on <code>ens33</code>. That means it&rsquo;s working. If you get an error here that says it doesn&rsquo;t, it&rsquo;s not configured to listen on any interfaces, that&rsquo;s where you might need to change that defaults file to listen on ens33 to work. So. That&rsquo;s how you can tell your DHCP server started correctly.</p>
<p>There&rsquo;s a couple other commands that you can use using the <code>ss</code> command to look at listening ports. So <code>ss -l</code> will show you all the listening ports on your system. However, it&rsquo;s not very useful at all. So instead, we can try two different versions, I&rsquo;m going to do <code>ss -l</code>, then I&rsquo;m going to do <code>t</code> which will listen for TCP ports only. And then <code>n</code> which will show us the port numbers. So if I do <code>ss -ltn</code>, I will see really quickly that I have a DNS server listening right here on port <code>53</code>. That&rsquo;s what we&rsquo;re looking for for DNS. DHCP, however, is not TCP is UDP. And so if I look for UDP, I&rsquo;ll see a DHCP server listening here on every IP address on port <code>67</code>. And so there is the entry for your DHCP server. And so if you&rsquo;re not sure if your servers are running correctly, you can use <code>ss -ltn</code> or <code>ss -lun</code> and look for entries that end in <code>53</code> for your DNS server or <code>67</code>, for your DHCP server.</p>
<p>You&rsquo;ll also notice that there is <code>161</code> for your SNMP server if you have that running. So this is kind of a really useful thing. You can also see your SSH server running on <code>22222</code>, and we&rsquo;ll see our HTTP server Apache running on port <code>80</code>. So a couple of quick commands.</p>
<p>But the really easy way to test your DHCP server is actually on Windows. And so on Windows, I have no static IP address set. If I do <code>ipconfig /release</code>, that will release all of our IP configurations. And then I can do <code>ipconfig /renew</code> to force it to renew that IP address. And so it will think for just a minute and then it will come back and it should give us an IP address that has something within our range. It has dot two as the gateway. But the big giveaway is you can find this connection-specific DNS suffix, and it will contain your eID. That&rsquo;s the dead giveaway that you are getting a DHCP address from your DHCP server. And that&rsquo;s why it&rsquo;s actually really easy to test this on Windows.</p>
<p>Now, if I do <code>ipconfig /all</code>, then it will show all the information. And you can see that it also is getting the DNS server for your network. And so it actually gets the right DNS server, it will also show you what your DHCP server is. So if you want to know where that IP address came from, you can find it here as well. And then, of course, we can use <code>nslookup</code> to look up different names on our network. So if I do <code>nslookup</code>, I can look that up. And if I do the reverse, I can get the reverse as well. So everything is looking really good here.</p>
<p>The other thing you can do, obviously, for testing is on your Ubuntu client, you can do <code>sudo dhclient -r</code>, which will run the DHCP client and refresh. If I do <code>sudo dhclient -v</code>, you&rsquo;ll actually see it sending the DHCP discover. So it sends to discover, then we get an offer of this IP address from our server IP. And you can see that it works.</p>
<p>So those are a quick overview of what lab three should look like when it&rsquo;s working correctly. The big things to do are get your DNS server up and running, and then test it here on your server using those <code>dig</code> commands with the at symbol on them. So if we go back through my history, we find some of these <code>dig</code> commands having the at symbol where we can query a particular DNS server and look up a particular address. Once you get that working, you can then test it from your client using that same syntax or you can just go ahead, get your DHCP server up and running, check the system log to make sure it&rsquo;s running. And then go to your Windows client, reboot it and make sure that it&rsquo;s getting an IP address from your system. And then you should be good to go.</p>
<p>If it&rsquo;s not working, check your config files, check your firewall, make sure that it&rsquo;s listening on the right ports, or feel free to reach out on Piazza and let us know. So I hope this video was helpful. If you have suggestions or questions or anything else I can go over please let me know.</p>
<p>Good luck.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="lab-3-networking-diagrams">Lab 3 Networking Diagrams</h1>

<p>Here are some helpful networking diagrams to better explain the desired state before and after the end of Lab 3. In all of these diagrams, I am using a sample network with the IP address <code>192.168.40.0</code>. You will have to adapt the IPs to match your network configuration. In addition, each network address will need to be updated with your unique eID as directed in the lab assignment.</p>
<h3 id="before-lab-3">Before Lab 3</h3>
<p>
<a href="#image-34063d07a8c889741b788f9776df718e" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/19-lab3-networking/../../images/net-beforelab3.png" alt="Before Lab 3" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-34063d07a8c889741b788f9776df718e">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/19-lab3-networking/../../images/net-beforelab3.png" alt="Before Lab 3" class="lightbox-image" loading="lazy">
</a></p>
<p>Once you&rsquo;ve completed Task 1 of Lab 3, you should have three virtual machines connected to your network. Each of them will be configured to automatically get an IP address using DHCP, and they will also be configured to use the automatically provided DNS information from that DHCP server. By default, the NAT network in VMware is configured to use VMware&rsquo;s built-in DHCP server to handle automatic IP addresses, and that DHCP server also configures each system to use VMware&rsquo;s built-in DNS server. That server can be found at <code>192.168.40.2</code>.</p>
<p>This is very similar to how most home networks are configured, where the wireless router acts as both a DHCP server and DNS server (in actuality, a DNS forwarder, since it doesn&rsquo;t really resolve DNS entries itself).</p>
<h3 id="after-lab-3">After Lab 3</h3>
<p>
<a href="#image-dc204191539686a462b43775ecd1726a" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/19-lab3-networking/../../images/net-afterlab3.png" alt="After Lab 3" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-dc204191539686a462b43775ecd1726a">
<img src="https://ksu-cs-textbooks.github.io/cis527/3-core-networking-services/19-lab3-networking/../../images/net-afterlab3.png" alt="After Lab 3" class="lightbox-image" loading="lazy">
</a></p>
<p>Once you&rsquo;ve completed all of Lab 3, your network diagram should resemble the one shown above. At this point, you have installed and configured both a DNS and a DHCP server on your Ubuntu VM labelled Server, and disabled the built-in DHCP server in VMware&rsquo;s NAT network. By doing so, your Ubuntu VM labelled Client as well as your Windows 10 VM will now be getting automatic IP addresses from your Ubuntu server. In addition, the DHCP server will configure those systems to use your Ubuntu server as the primary DNS server. So, whenever you try to access any addresses in the <code>cis527&lt;your eID&gt;.cs.ksu.edu</code> network on those systems, they will use your Ubuntu DNS server to look up the names.</p>
<p>However, notice that your Ubuntu VM labelled Server still uses the VMware DNS server as its primary entry. By doing so, it <strong>will not</strong> be able to look up any addresses in the <code>cis527&lt;your eID&gt;.cs.ksu.edu</code> network at this time. However, you can modify its DNS settings to include a secondary entry which points back to itself (it is important to use it&rsquo;s external <code>192.168.40.41</code> IP address for this, and not the localhost address <code>127.0.0.1</code>). By doing so, that will allow it to query itself for DNS entries it can&rsquo;t find, but will still guarantee it can access the internet even if your internal DNS server is not configured properly.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
          </section>

        </div>
      </main>
    
<div class="git-footer">
<p class="theme-version-footer">5.18.0</p>
<p>Last modified by: 
            <i class='fas fa-user'></i> Russell Feldhausen
            <i class='fas fa-calendar'></i> <a href="https://gitlab.cs.ksu.edu/cis-527/cis527online/-/commit/84061ea45bef3eaeed1adfe99c235e8c52dcaff8">Aug 10, 2023</a>
</p>
</div>

    
    </div>
    <script src="https://ksu-cs-textbooks.github.io/cis527/js/clipboard.min.js?1696352404" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis527/js/perfect-scrollbar.min.js?1696352404" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis527/js/theme.js?1696352404" defer></script>
  </body>
</html>
